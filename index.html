<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mysterious Journey</title>
    <style>
        /* Local Font Declarations */
        @font-face {
            font-family: 'Centaur';
            src: url('Fonts/CENTAUR.TTF') format('truetype');
            font-weight: normal;
            font-style: normal;
        }

        @font-face {
            font-family: 'Chiller';
            src: url('Fonts/CHILLER.TTF') format('truetype');
            font-weight: normal;
            font-style: normal;
        }

        @font-face {
            font-family: 'Copperplate Gothic';
            src: url('Fonts/COPRGTB.TTF') format('truetype');
            font-weight: bold;
            font-style: normal;
        }

        @font-face {
            font-family: 'Copperplate Gothic';
            src: url('Fonts/COPRGTL.TTF') format('truetype');
            font-weight: 300;
            font-style: normal;
        }

        @font-face {
            font-family: 'CAD';
            src: url('Fonts/CAD_____.TTF') format('truetype');
            font-weight: normal;
            font-style: normal;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            height: 100%;
            width: 100%;
        }

        body {
            font-family: 'Centaur', serif;
            overflow: hidden;
            margin: 0;
            padding: 0;
            height: 100vh;
            width: 100vw;
        }

        /* Wrapper for all content */
        #game-wrapper {
            width: 100%;
            height: 100%;
            position: relative;
        }

        /* Page containers */
        .page {
            display: none;
            width: 100vw;
            height: 100vh;
            position: relative;
            margin: 0;
            padding: 0;
            pointer-events: none;
        }

        .page > * {
            opacity: 0;
            transition: opacity 1.4s ease-in-out;
            will-change: opacity;
        }

        .page.active {
            pointer-events: auto;
        }

        .page.active > * {
            opacity: 1;
        }

        /* Ensure login page is always centered when active */
        .signup-page.active {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        /* Sign Up Page Styles */
        .signup-page {
            background-image: url('art/challenge-webpage-background.png');
            background-position: center center;
            background-size: cover;
            background-repeat: no-repeat;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 0;
            margin: 0;
            height: 100vh;
            width: 100vw;
            position: relative;
        }

        .signup-page::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: url('art/challenge-webpage-background-shadow-hue.png');
            background-position: center center;
            background-size: cover;
            background-repeat: no-repeat;
            z-index: 1;
        }

        .signup-container {
            max-width: 93.75rem;
            width: 100%;
            background: transparent;
            border-radius: 0;
            box-shadow: none;
            padding: 2.5rem;
            margin: 1.25rem;
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: center;
            position: relative;
            z-index: 2;
            height: 50rem;
            gap: 2.5rem;
        }

        .signup-title {
            font-size: 2.8rem;
            color: #ffffff;
            margin-top: 3.125rem;
            margin-bottom: -2.1875rem;
            text-align: center;
            font-weight: 100;
            letter-spacing: 0.0625rem;
            font-family: 'Centaur', serif;
        }

        .login-link {
            text-align: center;
            margin-top: 0;
            margin-bottom: 0;
            color: #ffffff;
            font-family: 'Centaur', serif;
            font-size: 1.25rem;
            font-weight: 100;
            letter-spacing: 0.0312rem;
            position: relative;
            z-index: 10;
        }

        .login-link a {
            color: #d6a550;
            text-decoration: none;
            font-size: 1.25rem;
            font-weight: 100;
        }

        .login-title-divider {
            width: 21.875rem !important;
            height: auto;
            opacity: 0.8;
            margin: 0.625rem auto 0.625rem auto;
            display: block;
        }

        .signup-content {
            display: flex;
            gap: 2.5rem;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
            transform: translateX(-1.75rem);
        }

        .intro-page {
            background: url('art/challenge-webpage-background.png') center/cover;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            width: 100vw;
            height: 100vh;
            padding-top: 8.125rem;
            box-sizing: border-box;
        }

        .intro-page::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: url('art/challenge-webpage-background-shadow-hue.png') center/cover;
            z-index: 1;
        }

        .intro-container {
            width: 100%;
            max-width: 87.5rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 0 2.5rem;
            position: relative;
            z-index: 2;
        }

        .intro-content {
            width: clamp(20rem, 80vw, 80rem);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 1.125rem;
        }

        .youtube-frame {
            width: clamp(20rem, 80vw, 80rem);
            aspect-ratio: 16 / 9;
            background: #000000;
            border-radius: 1.125rem;
            overflow: hidden;
            box-shadow: 0 2.5rem 5.625rem rgba(0, 0, 0, 0.55);
            position: relative;
        }

        .youtube-frame video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            background: #000000;
        }

        .youtube-progress,
        .youtube-progress-track,
        .youtube-progress-fill,
        .youtube-time {
            display: none;
        }

        .login-divider-stack {
            position: relative;
            width: 5.625rem;
            height: 25rem;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: none;
        }

        .login-divider-stack img {
            position: absolute;
            width: 25rem;
            height: auto;
            top: 50%;
            left: 50%;
            transform-origin: center center;
        }

        .login-divider-stack .divider-left {
            top: calc(50% + 0.8125rem);
            transform: translate(-50%, -50%) rotate(90deg);
        }

        .login-divider-stack .divider-right {
            top: calc(50% - 0.3125rem);
            left: calc(50% + 0.625rem);
            transform: translate(-50%, -50%) rotate(-90deg);
        }

        .login-form-container,
        .social-container {
            background: url('art/lightbox-medium.png') center/contain no-repeat;
            background-size: 100% 100%;
            width: 62.5rem;
            height: 46.875rem;
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            padding: 2.5rem 3.75rem 2.5rem;
            overflow: visible;
        }

        .login-header-section {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .login-form-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            position: absolute;
            top: 60%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .signup-form {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.125rem;
            overflow: visible;
        }

        .form-group {
            margin-bottom: 0;
            display: flex;
            justify-content: center;
            overflow: visible;
        }

        .form-group label {
            display: block;
            margin-bottom: 0.3125rem;
            color: #ffffff;
            font-weight: 100;
            font-family: 'Centaur', serif;
        }

        .form-group input {
            background: url('art/email-text-box.png') center/cover no-repeat;
            width: 28.75rem;
            height: 5rem;
            border: none;
            background-color: transparent;
            color: #d6a550;
            font-size: 1.25rem;
            padding: 1.25rem 1.875rem 0.75rem 1.875rem;
            text-align: center;
            font-family: 'Centaur', serif;
            font-style: normal;
            font-weight: 100;
            line-height: 1.2;
            transition: color 0.3s ease, text-shadow 0.3s ease;
            overflow: visible;
        }

        .form-group input:focus {
            outline: none;
            color: #e6ebff;
            text-shadow: 0 0 1rem rgba(151, 196, 255, 0.95), 0 0 2.125rem rgba(174, 110, 255, 0.55);
        }

        .form-group input::placeholder {
            color: #d6a550;
            opacity: 0.7;
            font-family: 'Centaur', serif;
            font-style: normal;
            font-weight: 100;
        }

        /* Override browser autofill styling */
        .form-group input:-webkit-autofill,
        .form-group input:-webkit-autofill:hover,
        .form-group input:-webkit-autofill:focus,
        .form-group input:-webkit-autofill:active {
            -webkit-background-clip: text;
            -webkit-text-fill-color: #d6a550;
            transition: background-color 5000s ease-in-out 0s;
            box-shadow: inset 0 0 1.25rem 1.25rem transparent;
            background-color: transparent !important;
        }

        .signup-btn {
            background: url('art/text-button-field.png') center/contain no-repeat;
            width: 34.375rem;
            max-width: 100vw;
            height: 7.8125rem;
            border: none;
            background-color: transparent;
            color: #d0d8ff;
            font-size: 1.5rem;
            font-weight: 100;
            cursor: pointer;
            transition: transform 0.3s ease, color 0.3s ease, text-shadow 0.3s ease;
            font-family: 'Centaur', serif;
            padding: 0 2.5rem;
            text-align: center;
            text-shadow: 0 0 0.5rem rgba(160, 190, 255, 0.85);
        }

        .signup-btn:disabled {
            pointer-events: none;
            filter: grayscale(35%);
            opacity: 0.75;
        }

        .signup-btn:hover {
            transform: translateY(-0.1875rem);
            color: #e6ebff;
            text-shadow: 0 0 0.875rem rgba(160, 190, 255, 0.95), 0 0 1.875rem rgba(174, 110, 255, 0.6);
        }

        .signup-btn.login-mode {
            margin-top: 2.5rem;
        }

        .divider {
            display: flex;
            align-items: center;
            gap: 0.625rem;
            margin: 1.25rem 0;
        }

        .divider::before,
        .divider::after {
            content: '';
            flex: 1;
            height: 0.0625rem;
            background: #e2e8f0;
        }

        .divider span {
            color: #ffffff;
            font-size: 0.875rem;
            font-family: 'Centaur', serif;
        }

        .social-buttons {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .discord-btn {
            background: none;
            width: auto;
            height: auto;
            border: none;
            font-size: 2.125rem;
            font-weight: 100;
            cursor: pointer;
            color: #f2d37c;
            font-family: 'Centaur', serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 0.125rem;
            text-transform: none;
            padding: 0;
        }

        .discord-btn:hover,
        .discord-btn:focus {
            outline: none;
        }

        .discord-btn:hover img:last-child,
        .discord-btn:focus img:last-child {
            filter: drop-shadow(0 0 1.25rem rgba(214, 165, 80, 0.55));
            transform: translateY(-0.375rem);
        }

        .discord-btn img {
            width: 12.5rem;
            height: auto;
            display: block;
            transition: filter 0.3s ease, transform 0.3s ease;
        }

        .discord-btn span {
            letter-spacing: 0.0625rem;
        }

        .discord-divider {
            width: 21.875rem !important;
            height: auto;
            opacity: 0.8;
            margin-left: 1.25rem;
            margin-top: -1.875rem;
        }

        .signup-info-footer {
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 160rem;
            height: auto;
            pointer-events: none;
            z-index: 3;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .signup-info-footer .footer-bg {
            width: 160rem;
            height: auto;
            display: block;
            image-rendering: crisp-edges;
        }

        .footer-content {
            position: absolute;
            bottom: -0.9375rem;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0;
            width: 90%;
            max-width: 75rem;
        }

        .footer-legal {
            text-align: center;
            color: #999999;
            font-size: 1.05rem;
            line-height: 1.5;
            font-family: 'Centaur', serif;
            max-width: 56.25rem;
            margin: 0 auto;
            position: relative;
            z-index: 2;
            margin-bottom: -1.875rem;
        }

        .footer-logos {
            display: flex;
            gap: 6.25rem;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
        }

        .footer-logos a {
            pointer-events: auto;
            display: inline-block;
        }

        .footer-logos img {
            height: 7.8125rem;
            width: 15.625rem;
            object-fit: contain;
            opacity: 0.8;
            transition: opacity 0.3s ease;
            padding-left: 2.1875rem;
            display: block;
        }

        .footer-logos a:hover img {
            opacity: 1;
        }

        .footer-logos .intrepid-logo {
            height: 7.0312rem;
            width: 12.5rem;
        }

        .footer-logos .aoc-logo {
            height: 8.2031rem;
            width: 16.4062rem;
        }

        /* Name Entry Page Styles */
        .name-entry-page {
            background: url('art/challenge-webpage-background.png') center/cover;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            width: 100vw;
            height: 100vh;
            margin: 0;
            padding: 0;
        }

        .name-entry-page::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: url('art/challenge-webpage-background-shadow-hue.png') center/cover;
            z-index: 1;
        }

        .name-entry-container {
            background: url('art/lightbox-medium.png') center/contain no-repeat;
            width: 62.5rem;
            height: 46.875rem;
            position: relative;
            margin: 0 auto;
            background-position: center center;
            top: 50%;
            transform: translateY(-50%);
            z-index: 2;
        }

        .name-entry-content {
            text-align: left;
            color: white;
            z-index: 2;
            width: 72%;
            padding: 0 0.625rem;
            max-width: 40rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            position: absolute;
            top: 7.8125rem;
            bottom: 5rem;
            left: 50%;
            transform: translateX(-50%);
        }

        .name-entry-body {
            margin-top: 2.5rem;
            width: 100%;
            max-width: 37.5rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1.125rem;
        }

        .stag-guidance {
            font-family: 'Centaur', serif;
            font-size: 1.4rem;
            color: #ffffff;
            margin-bottom: 0.3125rem;
            text-align: center;
            max-width: 26.25rem;
            word-wrap: break-word;
            overflow-wrap: break-word;
            white-space: normal;
            line-height: 1.5;
            margin-left: auto;
            margin-right: auto;
        }

        .golden-swirl {
            width: min(28.125rem, 74vw);
            max-width: 100%;
            height: auto;
            aspect-ratio: 450 / 70;
            background: url('art/divider.png') center/contain no-repeat;
            margin: -0.3125rem auto 1.25rem auto;
            display: block;
        }

        .riddle-content .golden-swirl {
            margin: -1.75rem auto 0.75rem auto !important;
        }

        .name-question {
            font-family: 'Centaur', serif;
            font-size: 1.2rem;
            color: #ffffff;
            margin-top: 0;
            margin-bottom: 1.125rem;
            text-align: left;
            width: 100%;
            max-width: 37.5rem;
        }

        .mysterious-signature {
            font-family: 'CAD', serif;
            font-style: normal;
            font-size: 1.7rem;
            color: #ffffff;
            text-align: left;
            margin-bottom: 1.5625rem;
            width: 100%;
            max-width: 26.25rem;
            font-weight: 100;
            align-self: flex-start;
            margin-left: 65%;
            margin-right: auto;
        }

        .name-input-container {
            position: relative;
            margin-top: 6.25rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .name-input {
            background: transparent;
            border: none;
            color: #d6a550;
            font-family: 'Centaur', serif;
            font-style: normal;
            font-size: 1.3rem;
            font-weight: 100;
            padding: 0 1.5625rem;
            text-align: center;
            outline: none;
            box-shadow: none;
            width: 25rem;
            height: 3.4375rem;
            position: absolute;
            top: 0.3125rem;
            z-index: 2;
        }

        .name-line {
            background: url('art/character-name-line.png') center/contain no-repeat;
            width: 25rem;
            height: 6.25rem;
            position: relative;
            z-index: 1;
        }

        .yellow-x {
            position: absolute;
            left: 2.5rem;
            top: 35%;
            transform: translateY(-50%);
            color: #d6a550;
            font-family: 'Chiller', cursive;
            font-style: normal;
            font-size: 2rem;
            font-weight: 100;
            z-index: 3;
        }

        .name-input:focus {
            outline: none;
            box-shadow: none;
            border: none;
        }

        .name-input::placeholder {
            color: #d6a550;
            opacity: 0.7;
            font-family: 'Centaur', serif;
            font-style: normal;
            font-weight: 100;
        }

        .hooded-figure {
            position: absolute;
            left: 2.375rem;
            top: 0.3125rem;
            width: 18.75rem;
            height: 15.625rem;
            background: url('art/hooded-figure.png') center/contain no-repeat;
            z-index: 1;
        }

        .stag-banner {
            position: absolute;
            right: 3.75rem;
            top: 2.8125rem;
            width: 18.75rem;
            height: 15.625rem;
            background: url('art/axiom-flag.png') center/contain no-repeat;
            z-index: 1;
        }

        /* Riddle Page Styles */
        .riddle-page {
            background: url('art/challenge-webpage-background.png') center/cover;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            width: 100vw;
            height: 100vh;
            margin: 0;
            padding: 0;
        }

        .riddle-page::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: url('art/challenge-webpage-background-shadow-hue.png') center/cover;
            z-index: 1;
        }

        .riddle-page .riddle-container,
        .riddle-page .riddle-content {
            opacity: 1;
            transition: opacity 0.6s ease;
        }

        .riddle-page .riddle-container.is-transitioning,
        .riddle-page .riddle-content.is-transitioning {
            opacity: 0;
        }

        .riddle-page.is-completion .riddle-container,
        .riddle-page.is-completion .riddle-hooded-figure,
        .riddle-page.is-completion .riddle-stag-banner {
            display: none;
        }

        .completion-container {
            position: relative;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
            padding: 5rem 2.5rem 6.5rem;
            z-index: 2;
            text-align: center;
        }

        .riddle-page.is-completion .completion-container {
            display: flex;
        }

        .completion-heading,
        .completion-subheading,
        .completion-reward-caption,
        .completion-modal-content h2,
        .completion-modal-content p {
            color: #ffffff;
            text-shadow: 0 0 1.25rem rgba(0, 0, 0, 0.8), 0 0 3rem rgba(0, 0, 0, 0.55);
        }

        .completion-heading {
            font-family: 'Centaur', serif;
            font-weight: 700;
            font-size: 2.6rem;
            letter-spacing: 0.2em;
            margin: 0 auto;
            max-width: min(36rem, 80vw);
        }

        .completion-subheading {
            font-family: 'Centaur', serif;
            font-size: 1.1rem;
            margin-top: 0.35rem;
            margin-bottom: 0.5rem;
            letter-spacing: 0.05em;
            max-width: min(32rem, 78vw);
            margin-left: auto;
            margin-right: auto;
        }

        .completion-divider {
            width: min(30rem, 85vw);
            margin: -1.25rem auto 2.5rem !important;
        }

        .golden-swirl.completion-divider {
            width: min(30rem, 85vw);
            height: 4.5rem;
            filter: drop-shadow(0 0 1.5rem rgba(0, 0, 0, 0.6));
            background-size: 100% 100% !important;
            position: relative;
            z-index: 1;
        }

        .completion-rewards {
            display: flex;
            align-items: flex-end;
            justify-content: center;
            gap: 5.75rem;
            position: relative;
            width: 100%;
            max-width: 78rem;
            margin-bottom: 3.5rem;
            transform: translateX(-1.5rem);
        }

        .completion-reward-button {
            background: none;
            border: none;
            padding: 0;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1.5rem;
            color: #ffffff;
            max-width: 21rem;
            transition: transform 0.25s ease;
        }

        .completion-reward-button:focus-visible {
            outline: 0.1875rem solid rgba(214, 165, 80, 0.85);
            outline-offset: 0.35rem;
        }

        .completion-reward-art {
            width: 30rem;
            height: auto;
            transition: filter 0.3s ease, transform 0.3s ease;
            filter: drop-shadow(0 0 1.25rem rgba(0, 0, 0, 0.55));
        }

        .completion-reward-button.is-selected .completion-reward-art {
            transform: translateY(-0.5rem);
        }

        @keyframes completionGlowTeal {
            0%, 100% { filter: drop-shadow(0 0 1.25rem rgba(0, 0, 0, 0.55)) drop-shadow(0 0 0.75rem rgba(48, 226, 176, 0.2)); }
            50% { filter: drop-shadow(0 0 1.25rem rgba(0, 0, 0, 0.55)) drop-shadow(0 0 0.75rem rgba(48, 226, 176, 0.2)); }
        }

        @keyframes completionGlowAmber {
            0%, 100% { filter: drop-shadow(0 0 1.25rem rgba(0, 0, 0, 0.55)) drop-shadow(0 0 0.75rem rgba(255, 183, 66, 0.2)); }
            50% { filter: drop-shadow(0 0 1.25rem rgba(0, 0, 0, 0.55)) drop-shadow(0 0 0.75rem rgba(255, 183, 66, 0.2)); }
        }

        @keyframes completionGlowAqua {
            0%, 100% { filter: drop-shadow(0 0 1.25rem rgba(0, 0, 0, 0.55)) drop-shadow(0 0 0.75rem rgba(92, 196, 255, 0.2)); }
            50% { filter: drop-shadow(0 0 1.25rem rgba(0, 0, 0, 0.55)) drop-shadow(0 0 0.75rem rgba(92, 196, 255, 0.2)); }
        }

        .completion-reward-button.is-selected[data-reward="armor"] .completion-reward-art {
            animation: completionGlowTeal 2.4s ease-in-out infinite;
        }

        .completion-reward-button.is-selected[data-reward="scroll"] .completion-reward-art {
            animation: completionGlowAmber 2.4s ease-in-out infinite;
        }

        .completion-reward-button.is-selected[data-reward="mount"] .completion-reward-art {
            animation: completionGlowAqua 2.4s ease-in-out infinite;
        }

        /* Hover glow effects for all completion items */
        .completion-reward-button:hover[data-reward="armor"] .completion-reward-art {
            filter: drop-shadow(0 0 1.25rem rgba(0, 0, 0, 0.55)) drop-shadow(0 0 0.75rem rgba(48, 226, 176, 0.2));
        }

        .completion-reward-button:hover[data-reward="scroll"] .completion-reward-art {
            filter: drop-shadow(0 0 1.25rem rgba(0, 0, 0, 0.55)) drop-shadow(0 0 0.75rem rgba(255, 183, 66, 0.2));
        }

        .completion-reward-button:hover[data-reward="mount"] .completion-reward-art {
            filter: drop-shadow(0 0 1.25rem rgba(0, 0, 0, 0.55)) drop-shadow(0 0 0.75rem rgba(92, 196, 255, 0.2));
        }

        /* Show selected image on hover */
        .completion-reward-button:hover[data-reward="armor"] .completion-reward-art {
            content: url('art/completion-armor-selected.png');
        }

        .completion-reward-button:hover[data-reward="scroll"] .completion-reward-art {
            content: url('art/completion-scroll-selected.png');
        }

        .completion-reward-button:hover[data-reward="mount"] .completion-reward-art {
            content: url('art/completion-mount-selected.png');
        }

        .completion-reward-caption {
            font-family: 'Centaur', serif;
            font-size: 1.2rem;
            line-height: 1.75;
            letter-spacing: 0.05em;
            text-shadow: 0 0 1rem rgba(0, 0, 0, 0.7), 0 0 2rem rgba(0, 0, 0, 0.45);
        }

        .completion-selector {
            position: absolute;
            bottom: -4.5rem;
            left: 0;
            width: 5.25rem;
            height: auto;
            transform: translateX(-9999px);
            transition: transform 0.35s ease;
            pointer-events: none;
            opacity: 0;
        }

        .completion-submit-btn {
            margin-top: 1.75rem;
            transform: scale(0.81);
            color: #ffffff;
            font-weight: 400;
            text-shadow: 0 0 1.25rem rgba(0, 0, 0, 0.85), 0 0 2.5rem rgba(0, 0, 0, 0.55);
        }
        .completion-modal {
            position: fixed;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .completion-modal.is-visible {
            display: flex;
        }

        .completion-modal-backdrop {
            position: absolute;
            inset: 0;
            background: rgba(4, 6, 12, 0.78);
            backdrop-filter: blur(0.35rem);
        }

        .completion-modal-content {
            position: relative;
            width: min(34rem, 90vw);
            padding: 3.25rem 2.5rem 3rem;
            background: rgba(13, 11, 9, 0.92);
            border: 0.125rem solid rgba(214, 165, 80, 0.45);
            border-radius: 1.25rem;
            box-shadow: 0 1.5rem 4rem rgba(0, 0, 0, 0.6), inset 0 0 2.5rem rgba(214, 165, 80, 0.15);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1.5rem;
            text-align: center;
        }

        .completion-modal-content h2 {
            font-family: 'Centaur', serif;
            font-size: 2.15rem;
            font-weight: 400;
            color: #ffffff;
            margin: 0;
            text-shadow: 0 0 1.25rem rgba(0, 0, 0, 0.85);
        }

        .completion-modal-content p {
            font-family: 'Centaur', serif;
            font-size: 1.2rem;
            line-height: 1.75;
            color: #ffffff;
            margin: 0;
            text-shadow: 0 0 0.85rem rgba(0, 0, 0, 0.75);
        }

        .completion-modal-discord {
            display: inline-flex;
            align-items: center;
            gap: 0.75rem;
            margin-top: 0.75rem;
            text-decoration: none;
            color: #d6a550;
            font-family: 'Centaur', serif;
            font-size: 1.1rem;
            text-shadow: 0 0 0.85rem rgba(0, 0, 0, 0.75);
            transition: transform 0.2s ease;
        }

        .completion-modal-discord:hover {
            transform: translateY(-0.15rem);
        }

        .completion-modal-discord-icon {
            width: 2.75rem;
            height: 2.75rem;
        }

        .completion-modal-btn {
            transform: scale(0.9);
            text-shadow: 0 0 1rem rgba(0, 0, 0, 0.85), 0 0 2rem rgba(0, 0, 0, 0.55);
        }

        .riddle-content .stag-guidance,
        .riddle-content .golden-swirl,
        .riddle-content .mysterious-signature,
        .riddle-dialog,
        .riddle-question,
        .trust-question {
            user-select: none;
            -webkit-user-select: none;
            -ms-user-select: none;
        }

        .riddle-container {
            background: url('art/lightbox-medium.png') center/contain no-repeat;
            width: 62.5rem;
            height: 46.875rem;
            position: relative;
            margin: 0 auto;
            background-position: center center;
            top: 50%;
            transform: translateY(-50%);
            z-index: 2;
            opacity: 1;
            transition: opacity 0.6s ease;
        }

        .riddle-container[data-riddle-id="8"],
        .riddle-container[data-riddle-id="17"],
        .riddle-container[data-riddle-id="21"],
        .riddle-container[data-riddle-id="22"] {
            background: url('art/lightbox-XL.png') center/contain no-repeat;
            width: 87.5rem;
            height: 65.625rem;
        }

        .riddle-content {
            text-align: left;
            color: white;
            z-index: 2;
            width: 72%;
            padding: 0 0.625rem 1.875rem;
            max-width: 40rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            position: absolute;
            top: 6.875rem;
            bottom: 3rem;
            left: 50%;
            transform: translateX(-50%);
            opacity: 1;
            transition: opacity 0.6s ease;
        }

        /* XL lightbox - text towards top, input anchored at bottom */
        .riddle-container[data-riddle-id="8"] .riddle-content,
        .riddle-container[data-riddle-id="17"] .riddle-content,
        .riddle-container[data-riddle-id="21"] .riddle-content,
        .riddle-container[data-riddle-id="22"] .riddle-content {
            top: 5rem;
            bottom: 0;
            padding-bottom: 3rem;
        }

        /* XL lightbox - ensure golden-swirl divider is visible */
        .riddle-container[data-riddle-id="8"] .golden-swirl,
        .riddle-container[data-riddle-id="17"] .golden-swirl,
        .riddle-container[data-riddle-id="21"] .golden-swirl,
        .riddle-container[data-riddle-id="22"] .golden-swirl {
            display: block !important;
            position: relative;
            z-index: 10;
            flex-shrink: 0;
            margin: -0.5rem auto 0.75rem auto;
        }

        /* XL lightbox - tighten stag-guidance spacing */
        .riddle-container[data-riddle-id="8"] .stag-guidance,
        .riddle-container[data-riddle-id="17"] .stag-guidance,
        .riddle-container[data-riddle-id="21"] .stag-guidance,
        .riddle-container[data-riddle-id="22"] .stag-guidance {
            flex-shrink: 0;
            margin-bottom: 0.1875rem;
        }

        /* XL lightbox - tighten riddle dialog spacing */
        .riddle-container[data-riddle-id="8"] .riddle-dialog,
        .riddle-container[data-riddle-id="17"] .riddle-dialog,
        .riddle-container[data-riddle-id="21"] .riddle-dialog,
        .riddle-container[data-riddle-id="22"] .riddle-dialog {
            flex-shrink: 0;
            margin-top: 1.5625rem;
            margin-bottom: 0.75rem;
            gap: 0.75rem;
        }

        /* XL lightbox - tighten riddle question spacing */
        .riddle-container[data-riddle-id="8"] .riddle-question,
        .riddle-container[data-riddle-id="17"] .riddle-question,
        .riddle-container[data-riddle-id="21"] .riddle-question,
        .riddle-container[data-riddle-id="22"] .riddle-question {
            margin-top: 0.5rem;
            margin-bottom: 0.75rem;
        }

        /* XL lightbox - tighten signature spacing */
        .riddle-container[data-riddle-id="8"] .mysterious-signature,
        .riddle-container[data-riddle-id="17"] .mysterious-signature,
        .riddle-container[data-riddle-id="21"] .mysterious-signature,
        .riddle-container[data-riddle-id="22"] .mysterious-signature {
            flex-shrink: 0;
            margin-bottom: 0.75rem;
        }

        /* XL lightbox - tighten map spacing for riddle 8 */
        .riddle-container[data-riddle-id="8"] .riddle-map {
            margin: 0.5rem 0;
        }

        /* XL lightbox - tighten disclaimer spacing for riddles 17, 21, and 22 */
        .riddle-container[data-riddle-id="17"] .riddle-disclaimer,
        .riddle-container[data-riddle-id="21"] .riddle-disclaimer,
        .riddle-container[data-riddle-id="22"] .riddle-disclaimer {
            margin: 0.5rem 0;
        }

        .riddle-dialog {
            font-family: 'Centaur', serif;
            font-size: 1.2rem;
            color: #ffffff;
            margin-top: 3.125rem;
            margin-bottom: 1.25rem;
            text-align: left;
            width: 100%;
            max-width: 37.5rem;
            display: flex;
            flex-direction: column;
            gap: 1.125rem;
        }

        .riddle-dialog p {
            margin: 0;
        }

        .riddle-question {
            font-family: 'Centaur', serif;
            font-size: 1.2rem;
            color: #ffffff;
            margin-top: 0.625rem;
            margin-bottom: 1.125rem;
            width: 100%;
            max-width: 37.5rem;
        }

        .riddle-question.highlight {
            color: #d6a550;
            font-family: 'CAD', serif;
            font-size: 1.5rem;
            letter-spacing: 0.04em;
        }

        .trust-question {
            color: #d6a550;
            font-family: 'CAD', serif;
            font-size: 1.5rem;
            letter-spacing: 0.04em;
        }
        
        .cad-word {
            font-family: 'CAD', serif;
        }
        
        .centaur-punct {
            font-family: 'Centaur', serif;
            font-style: italic;
        }

        .riddle-map {
            width: 100%;
            max-width: 43.75rem;
            height: auto;
            margin: 1.25rem 0;
            display: block;
        }

        /* Interactive map container for riddle 8 */
        .interactive-map-container {
            position: relative;
            width: 100%;
            max-width: 43.75rem;
            margin: 1.25rem auto;
            display: inline-block;
        }

        /* Allow map to overlap with input on riddle 8 */
        .riddle-container[data-riddle-id="8"] .interactive-map-container {
            margin-top: -2rem;
            margin-bottom: 1.5rem;
            z-index: 1;
        }

        .interactive-map-container .riddle-map {
            width: 100%;
            height: auto;
            display: block;
            margin: 0;
        }

        /* Clickable area on the map */
        .map-clickable-area {
            position: absolute;
            cursor: pointer;
            transition: opacity 0.3s ease;
        }

        .map-clickable-area:hover {
            opacity: 0.8;
        }

        /* Steelbloom glow overlay */
        .steelbloom-glow {
            position: absolute;
            position: absolute;
        top: 26%;
        left: 28.5%;
        width: 14%;
            height: auto;
            opacity: 0;
            pointer-events: none;
            transition: opacity 1s ease;
            object-fit: contain;
        }

        .steelbloom-glow.revealed {
            opacity: 1;
            animation: pulseRedGlow 2s ease-in-out infinite;
        }

        @keyframes pulseRedGlow {
            0%, 100% {
                filter: drop-shadow(0 0 0.5rem rgba(255, 0, 0, 0.9)) drop-shadow(0 0 0.75rem rgba(255, 0, 0, 0.7)) drop-shadow(0 0 1rem rgba(255, 0, 0, 0.5));
                opacity: 0.3;
                transform: scale(1);
            }
            50% {
                filter: drop-shadow(0 0 0.75rem rgba(255, 0, 0, 1)) drop-shadow(0 0 1.125rem rgba(255, 0, 0, 0.95)) drop-shadow(0 0 1.5rem rgba(255, 0, 0, 0.8));
                opacity: 1;
                transform: scale(1.05);
            }
        }

        /* Flute game container for riddle 21 */
        .flute-game-container {
            position: relative;
            width: 100%;
            max-width: 43.75rem;
            margin: 3.75rem auto 2.5rem auto;
            display: inline-block;
            transform: scale(1.2);
            transform-origin: center top;
        }

        #flute-buttons-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 2;
        }

        /* Allow flute game to overlap with input on riddle 21 */
        .riddle-container[data-riddle-id="21"] .flute-game-container {
            margin-bottom: -2.5rem;
            z-index: 1;
        }

        /* Class rune game container for riddle 22 */
        .class-rune-game-container {
            position: relative;
            width: 100%;
            max-width: 43.75rem;
            margin: 1.25rem auto;
            display: inline-block;
        }

        /* Allow class rune game to overlap with input on riddle 22 */
        .riddle-container[data-riddle-id="22"] .class-rune-game-container {
            margin-top: -2rem;
            margin-bottom: 1.5rem;
            z-index: 1;
        }

        /* Pyrai symbol game container for riddle 17 */
        .pyrai-symbol-game-container {
            position: relative;
            width: 100%;
            max-width: 43.75rem;
            margin: 1.25rem auto;
            display: inline-block;
        }

        /* Allow Pyrai symbol game to overlap with input on riddle 17 */
        .riddle-container[data-riddle-id="17"] .pyrai-symbol-game-container {
            margin-top: -2rem;
            margin-bottom: 1.5rem;
            z-index: 1;
        }

        .class-rune-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(2, 1fr);
            gap: 2.5rem;
            width: 100%;
            max-width: 55rem;
            margin: 2rem auto 0 auto;
            margin-left: -5rem;
            padding: 2rem;
        }

        .pyrai-symbol-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(2, 1fr);
            gap: 2.5rem;
            width: 100%;
            max-width: 55rem;
            margin: 2rem auto 0 auto;
            margin-left: -5rem;
            padding: 2rem;
        }

        .class-rune-button {
            position: relative;
            width: 10rem;
            height: 10rem;
            background: none;
            border: none;
            cursor: pointer;
            padding: 0;
            transition: transform 0.2s ease, filter 0.3s ease;
            justify-self: center;
        }

        .class-rune-button:hover {
            transform: scale(1.05);
        }

        .class-rune-button:active {
            transform: scale(0.95);
        }

        .class-rune-button img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            transition: opacity 0.3s ease, filter 0.3s ease;
        }

        .class-rune-button .inactive-img {
            display: block;
            opacity: 0.6;
        }

        .class-rune-button .active-img {
            display: none;
            opacity: 1;
        }

        .class-rune-button .wrong-img {
            display: none;
            opacity: 1;
        }

        .class-rune-button.selected .inactive-img {
            display: none !important;
        }

        .class-rune-button.selected .active-img {
            display: block !important;
        }

        .class-rune-button.wrong .inactive-img {
            display: none !important;
        }

        .class-rune-button.wrong .active-img {
            display: none !important;
        }

        .class-rune-button.wrong .wrong-img {
            display: block !important;
        }

        .class-rune-button.wrong {
            animation: wrongRuneEffect 0.5s ease-in-out;
        }

        .pyrai-symbol-button {
            position: relative;
            width: 10rem;
            height: 10rem;
            background: none;
            border: none;
            cursor: pointer;
            padding: 0;
            transition: transform 0.2s ease, filter 0.3s ease;
            justify-self: center;
            pointer-events: auto;
        }

        .pyrai-symbol-button:hover {
            transform: scale(1.05);
        }

        .pyrai-symbol-button:active {
            transform: scale(0.95);
        }

        .pyrai-symbol-button img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            transition: opacity 0.3s ease, filter 0.3s ease;
        }

        .pyrai-symbol-button .inactive-img {
            display: block;
            opacity: 0.6;
        }

        .pyrai-symbol-button .active-img {
            display: none;
            opacity: 1;
        }

        .pyrai-symbol-button .wrong-img {
            display: none;
            opacity: 1;
        }

        .pyrai-symbol-button.selected .inactive-img {
            display: none !important;
        }

        .pyrai-symbol-button.selected .active-img {
            display: block !important;
        }

        .pyrai-symbol-button.wrong .inactive-img {
            display: none !important;
        }

        .pyrai-symbol-button.wrong .wrong-img {
            display: block !important;
        }

        .pyrai-symbol-button.wrong:not(.completed) {
            animation: wrongRuneEffect 0.5s ease-in-out;
        }

        .pyrai-symbol-button.completed {
            pointer-events: none;
        }

        @keyframes wrongRuneEffect {
            0% { filter: none; }
            50% { filter: hue-rotate(-15deg) saturate(2) brightness(1.1) drop-shadow(0 0 0.5rem rgba(204, 0, 153, 0.45)); }
            100% { filter: none; }
        }

        .flute-game-container .flute-lines {
            width: 100%;
            height: auto;
            display: block;
            margin: 0;
        }

        /* Flute that moves across the lines */
        .flute-moving {
            position: absolute;
            top: 0;
            left: 0;
            bottom: 20%;
            width: auto;
            height: 100%;
            min-width: 6.875rem;
            pointer-events: none;
            transition: left 0s linear;
            object-fit: contain;
            z-index: 3;
        }

        .flute-shadow {
            position: absolute;
            left: 0;
            right: 0;
            bottom: 15%;
            height: 18%;
            background: radial-gradient(ellipse at center, rgba(0, 0, 0, 0.28) 0%, rgba(0, 0, 0, 0.05) 60%, rgba(0, 0, 0, 0) 100%);
            z-index: 2;
            pointer-events: none;
        }

        /* Flute buttons on the lines */
        .flute-button {
            position: absolute;
            width: 4.125rem;
            height: 4.125rem;
            cursor: pointer;
            transition: filter 0.3s ease, transform 0.3s ease, width 0.3s ease, height 0.3s ease;
            filter: brightness(0.75);
            transform: translate(-50%, -50%) scale(0.65);
            transform-origin: center;
            object-fit: contain;
            image-rendering: auto;
            will-change: transform;
            --flute-glow-color-base: rgba(255, 215, 0, 0.675);
            --flute-glow-color-strong: rgba(255, 215, 0, 0.855);
            --flute-glow-color-soft: rgba(255, 215, 0, 0.495);
            z-index: 2;
            pointer-events: none;
        }

        .flute-button.activated {
            filter: brightness(1) drop-shadow(0 0 0.375rem var(--flute-glow-color-base)) drop-shadow(0 0 0.75rem var(--flute-glow-color-soft));
            transform: translate(-50%, -50%) scale(1.6);
            animation: flute-glow 2.8s ease-in-out infinite;
        }

        .flute-button.flute-glow-violet {
            --flute-glow-color-base: rgba(170, 120, 255, 0.81);
            --flute-glow-color-strong: rgba(200, 170, 255, 0.9);
            --flute-glow-color-soft: rgba(135, 100, 235, 0.54);
        }

        .flute-button.flute-glow-crimson {
            --flute-glow-color-base: rgba(255, 110, 40, 0.81);
            --flute-glow-color-strong: rgba(255, 150, 80, 0.9);
            --flute-glow-color-soft: rgba(255, 90, 30, 0.54);
        }

        .flute-button.flute-glow-neon-green {
            --flute-glow-color-base: rgba(125, 255, 120, 0.81);
            --flute-glow-color-strong: rgba(180, 255, 180, 0.9);
            --flute-glow-color-soft: rgba(100, 255, 150, 0.54);
        }

        .flute-button.flute-glow-neon-blue {
            --flute-glow-color-base: rgba(120, 220, 255, 0.81);
            --flute-glow-color-strong: rgba(170, 240, 255, 0.9);
            --flute-glow-color-soft: rgba(110, 200, 255, 0.585);
        }

        .flute-button.flute-glow-neon-yellow {
            --flute-glow-color-base: rgba(255, 255, 140, 0.855);
            --flute-glow-color-strong: rgba(255, 255, 200, 0.9);
            --flute-glow-color-soft: rgba(255, 250, 120, 0.585);
        }

        .flute-button.flute-glow-neon-orange {
            --flute-glow-color-base: rgba(255, 180, 70, 0.855);
            --flute-glow-color-strong: rgba(255, 210, 130, 0.9);
            --flute-glow-color-soft: rgba(255, 160, 60, 0.585);
        }

        @keyframes flute-glow {
            0%, 100% {
                filter: brightness(1) drop-shadow(0 0 0.375rem var(--flute-glow-color-base)) drop-shadow(0 0 0.75rem var(--flute-glow-color-soft));
            }
            50% {
                filter: brightness(1.18) drop-shadow(0 0 0.75rem var(--flute-glow-color-strong)) drop-shadow(0 0 1.5rem var(--flute-glow-color-soft));
            }
        }

        .riddle-input-container {
            text-align: center;
            width: 100%;
            display: flex;
            justify-content: center;
            margin-top: auto;
            padding-top: 1.875rem;
            margin-bottom: 0;
        }

        /* XL lightbox - anchor input at bottom */
        .riddle-container[data-riddle-id="8"] .riddle-input-container {
            padding-top: 0;
            margin-bottom: 4rem;
            position: relative;
            top: -2.5rem;
            z-index: 2;
        }

        .riddle-container[data-riddle-id="2"] .riddle-input-container {
            padding-top: 0rem;
        }

        .riddle-container[data-riddle-id="17"] .riddle-input-container {
            padding-top: 0.5rem;
        }
        
        .riddle-container[data-riddle-id="21"] .riddle-input-container {
            padding-top: 2.5rem;
        }

        /* Hide input container for riddle 22 */
        .riddle-container[data-riddle-id="22"] .riddle-input-container {
            display: none;
        }

        .riddle-input {
            background: url('art/text-button-field.png') center/contain no-repeat;
            width: 295.3125rem;
            height: 7.5rem;
            border: none;
            background-color: transparent;
            color: #d0d8ff;
            font-size: 1.25rem;
            padding: 0 1.875rem;
            text-align: center;
            font-family: 'Centaur', serif;
            font-weight: 100;
            text-shadow: 0 0 0.5625rem rgba(151, 196, 255, 0.8);
            caret-color: transparent;
            transition: color 0.3s ease, text-shadow 0.3s ease;
        }

        .riddle-input:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            filter: grayscale(100%);
        }

        .riddle-input:focus {
            outline: none;
            color: #e6ebff;
            text-shadow: 0 0 1rem rgba(151, 196, 255, 0.95), 0 0 2.125rem rgba(174, 110, 255, 0.55);
        }

        .riddle-input::placeholder {
            color: rgba(208, 216, 255, 0.5);
            font-family: 'Centaur', serif;
        }

        .riddle-input.success {
            color: #6cd3a0;
            text-shadow: 0 0 1.125rem rgba(108, 211, 160, 0.45);
        }

        .riddle-input.error {
            color: #ff7676;
            text-shadow: 0 0 1.125rem rgba(255, 118, 118, 0.6);
        }

        .riddle-hooded-figure {
            position: absolute;
            left: 3.75rem;
            top: -0.625rem;
            width: 18.75rem;
            height: 15.625rem;
            background: center/contain no-repeat;
            z-index: 1;
        }

        .riddle-stag-banner {
            position: absolute;
            right: 3.75rem;
            top: 2.8125rem;
            width: 18.75rem;
            height: 15.625rem;
            background: url('art/axiom-flag.png') center/contain no-repeat;
            z-index: 1;
        }

        /* XL lightbox specific positioning - higher and closer together */
        .riddle-container[data-riddle-id="8"] .riddle-hooded-figure,
        .riddle-container[data-riddle-id="17"] .riddle-hooded-figure,
        .riddle-container[data-riddle-id="21"] .riddle-hooded-figure,
        .riddle-container[data-riddle-id="22"] .riddle-hooded-figure {
            left: 11.875rem;
            top: -2.1875rem;
        }

        .riddle-container[data-riddle-id="8"] .riddle-stag-banner,
        .riddle-container[data-riddle-id="17"] .riddle-stag-banner,
        .riddle-container[data-riddle-id="21"] .riddle-stag-banner,
        .riddle-container[data-riddle-id="22"] .riddle-stag-banner {
            right: 13.75rem;
            top: 0.3125rem;
        }

        /* Navigation */
        .nav-bar {
            position: fixed;
            top: -0.75rem;
            left: 50%;
            transform: translateX(-50%);
            width: 160rem;
            height: 6.25rem;
            background: url('art/navbar.png') center top no-repeat;
            background-size: 512rem 6.25rem;
            z-index: 1000;
            display: block;
            pointer-events: none;
        }

        .nav-audio-toggle {
            position: fixed;
            top: 0.75rem;
            left: 50%;
            margin-left: 68.75rem;
            width: 9rem;
            height: 2.375rem;
            border: none;
            border-radius: 0.625rem;
            background: transparent;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0;
            padding: 0 0.75rem;
            transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
            z-index: 1100;
            pointer-events: auto;
            overflow: hidden;
        }

        .nav-audio-toggle:hover {
            background: transparent;
            box-shadow: none;
            transform: translateY(-0.125rem);
        }

        .nav-audio-toggle svg {
            width: 1.75rem;
            height: 1.75rem;
            fill: none;
            stroke: #f4e3c1;
            stroke-width: 2;
            stroke-linecap: round;
            stroke-linejoin: round;
            flex-shrink: 0;
        }

        .nav-audio-toggle.is-muted svg {
            stroke: #ff6b6b;
        }

        .volume-slider {
            -webkit-appearance: none;
            appearance: none;
            width: 0;
            height: 0.25rem;
            background: rgba(214, 165, 80, 0.3);
            border-radius: 0.125rem;
            outline: none;
            flex: 0 0 auto;
            opacity: 0;
            margin-left: 0;
            pointer-events: none;
            transition: width 0.2s ease, opacity 0.2s ease, margin 0.2s ease;
        }

        .nav-audio-toggle:hover .volume-slider,
        .nav-audio-toggle:focus-within .volume-slider {
            width: 5rem;
            opacity: 1;
            margin-left: 0.5rem;
            pointer-events: auto;
        }

        .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 0.75rem;
            height: 0.75rem;
            background: #f4e3c1;
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.2s ease;
        }

        .volume-slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }

        .volume-slider::-moz-range-thumb {
            width: 0.75rem;
            height: 0.75rem;
            background: #f4e3c1;
            border-radius: 50%;
            cursor: pointer;
            border: none;
            transition: transform 0.2s ease;
        }

        .volume-slider::-moz-range-thumb:hover {
            transform: scale(1.2);
        }

        .page-transition-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #000000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
            z-index: 2000;
        }

        .page-transition-overlay.visible {
            opacity: 1;
        }

        /* Landscape-only requirement for mobile */
        .rotate-screen-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #000;
            z-index: 10000;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #ffffff;
            font-family: 'Centaur', serif;
            text-align: center;
            padding: 2.5rem;
        }

        .rotate-icon {
            width: 5rem;
            height: 5rem;
            margin-bottom: 1.875rem;
            animation: rotate-pulse 2s ease-in-out infinite;
        }

        .rotate-icon svg {
            width: 100%;
            height: 100%;
            fill: #d6a550;
        }

        .rotate-message {
            font-size: 1.5rem;
            color: #d6a550;
            margin-bottom: 0.9375rem;
            letter-spacing: 0.0625rem;
        }

        .rotate-submessage {
            font-size: 1rem;
            color: rgba(255, 255, 255, 0.7);
        }

        @keyframes rotate-pulse {
            0%, 100% {
                transform: rotate(0deg) scale(1);
                opacity: 0.8;
            }
            50% {
                transform: rotate(90deg) scale(1.1);
                opacity: 1;
            }
        }

        /* Show rotation overlay only on mobile devices in portrait mode */
        @media screen and (max-width: 64rem) and (orientation: portrait) {
            .rotate-screen-overlay {
                display: flex;
            }
            
            #game-wrapper {
                display: none;
            }
        }

        /* Ensure content shows on mobile landscape */
        @media screen and (max-width: 64rem) and (orientation: landscape) {
            .rotate-screen-overlay {
                display: none;
            }
            
            #game-wrapper {
                display: block;
            }
        }

        /* Button styles */
        .btn {
            padding: 0.625rem 1.25rem;
            border: none;
            border-radius: 0.3125rem;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.3s;
        }

        .btn-primary {
            background: #3182ce;
            color: white;
        }

        .btn-primary:hover {
            background: #2c5282;
        }

        /* Responsive design */
        @media (max-width: 48rem) {
            .signup-content {
                flex-direction: column;
            }
            
            .signup-container {
                margin: 0.625rem;
                padding: 1.25rem;
            }
            
            .name-entry-container,
            .riddle-container {
                width: 95%;
                height: 40.625rem;
                margin: 0 auto;
                top: 50%;
                transform: translateY(-50%);
            }
            
            .riddle-content {
                top: 5.625rem;
            }
            
            .hooded-figure,
            .riddle-hooded-figure {
                left: 2.5rem;
                top: -0.4375rem;
                width: 12.5rem;
                height: 11.25rem;
            }
            
            .stag-banner,
            .riddle-stag-banner {
                right: 2.25rem;
                top: 1.5625rem;
                width: 12.5rem;
                height: 11.25rem;
            }
            
            .name-input {
                width: 20rem;
                height: 2.8125rem;
                font-size: 1.375rem;
                font-weight: 100;
                top: 0.3125rem;
            }
            
            .name-line {
                width: 20rem;
                height: 5rem;
            }
            
            .yellow-x {
                font-size: 1.375rem;
                font-weight: 100;
                left: 1.875rem;
                top: 35%;
            }
            
            .golden-swirl {
                width: 22.5rem;
                height: 3.4375rem;
            }
            
            .name-entry-content,
            .riddle-content {
                width: 82%;
                max-width: 32.5rem;
                top: 6.25rem;
            }
            
            .riddle-input {
                width: 232rem;
                height: 6.25rem;
                font-size: 1.25rem;
            }
        }
        
        @media (max-width: 30rem) {
            .signup-container {
                margin: 0.3125rem;
                padding: 0.9375rem;
            }
            
            .name-entry-container,
            .riddle-container {
                width: 98%;
                height: 34.375rem;
                top: 50%;
                transform: translateY(-50%);
            }
            
            .hooded-figure,
            .riddle-hooded-figure {
                left: 1.875rem;
                top: -0.3125rem;
                width: 9.375rem;
                height: 9.375rem;
            }
            
            .stag-banner,
            .riddle-stag-banner {
                right: 1.9375rem;
                top: 1.25rem;
                width: 9.375rem;
                height: 9.375rem;
            }
            
            .name-input {
                width: 16.25rem;
                height: 2.5rem;
                font-size: 1.25rem;
                font-weight: 100;
                top: 0.3125rem;
            }
            
            .name-line {
                width: 16.25rem;
                height: 4.375rem;
            }
            
            .yellow-x {
                font-size: 1.25rem;
                font-weight: 100;
                left: 1.5625rem;
                top: 35%;
            }
            
            .golden-swirl {
                width: 17.5rem;
                height: 2.8125rem;
            }
            
            .name-entry-content,
            .riddle-content {
                top: 5.625rem;
                width: 86%;
                max-width: 27.5rem;
            }
            
            .riddle-input {
                width: 189.8125rem;
                height: 5.625rem;
                font-size: 1.25rem;
            }
        }

        .dev-console-overlay {
            position: fixed;
            left: 0;
            top: 0;
            bottom: 0;
            width: 26.25rem;
            z-index: 3200;
            pointer-events: none;
            transform: translateX(-100%);
            transition: transform 0.35s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .dev-console-overlay.is-visible {
            pointer-events: auto;
            transform: translateX(0);
        }

        .dev-console-modal {
            width: 100%;
            height: 100%;
            background: rgba(18, 16, 12, 0.97);
            border-right: 0.125rem solid rgba(214, 165, 80, 0.5);
            box-shadow: 0.25rem 0 2.5rem rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
        }

        .dev-console-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 1.25rem 1.625rem;
            background: linear-gradient(90deg, rgba(26, 20, 14, 0.98), rgba(36, 28, 20, 0.96));
            border-bottom: 0.0625rem solid rgba(214, 165, 80, 0.35);
        }

        .dev-console-title {
            font-size: 1.375rem;
            font-weight: 100;
            color: #f2d37c;
            letter-spacing: 0.04em;
        }

        .dev-console-header-actions {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .dev-console-close {
            background: transparent;
            border: 0.0625rem solid rgba(214, 165, 80, 0.35);
            color: #f9ebe1;
            font-size: 0.875rem;
            cursor: pointer;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            transition: background 0.2s ease, transform 0.2s ease;
            font-weight: 100;
        }

        .dev-console-close:hover {
            background: rgba(214, 165, 80, 0.22);
            transform: translateY(-0.0625rem);
        }

        .dev-console-close-btn {
            background: transparent;
            border: 0.0625rem solid rgba(214, 165, 80, 0.35);
            color: #f9ebe1;
            font-size: 1.5rem;
            cursor: pointer;
            width: 2.25rem;
            height: 2.25rem;
            border-radius: 0.5rem;
            transition: background 0.2s ease, transform 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1;
        }

        .dev-console-close-btn:hover {
            background: rgba(255, 107, 107, 0.25);
            border-color: rgba(255, 107, 107, 0.5);
            color: #ffb3b3;
            transform: scale(1.05);
        }

        .dev-console-toggle-btn {
            position: fixed;
            left: 0;
            top: 50%;
            transform: translateY(-50%) translateX(-100%);
            background: rgba(18, 16, 12, 0.95);
            border: 0.125rem solid rgba(214, 165, 80, 0.5);
            border-left: none;
            border-radius: 0 0.75rem 0.75rem 0;
            color: #f2d37c;
            font-size: 0.875rem;
            cursor: pointer;
            padding: 0.75rem 0.5rem;
            z-index: 3100;
            writing-mode: vertical-rl;
            text-orientation: mixed;
            transition: all 0.35s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0.125rem 0 0.9375rem rgba(0, 0, 0, 0.5);
        }

        .dev-console-toggle-btn.is-visible {
            transform: translateY(-50%) translateX(0);
        }

        .dev-console-toggle-btn:hover {
            background: rgba(214, 165, 80, 0.25);
        }

        .dev-console-toggle-btn.panel-open {
            left: 26.25rem;
        }

        .dev-console-body {
            display: flex;
            flex-direction: column;
            padding: 1.25rem 1.625rem 1.625rem;
            gap: 1.125rem;
            overflow-y: auto;
        }

        .dev-console-auth {
            display: flex;
            flex-direction: column;
            gap: 0.875rem;
            align-items: center;
            text-align: center;
        }

        .dev-console-auth label {
            font-size: 1rem;
            color: #f9ebe1;
        }

        .dev-console-password-input {
            width: 15rem;
            padding: 0.75rem 1rem;
            border-radius: 0.625rem;
            border: 0.0625rem solid rgba(214, 165, 80, 0.4);
            background: rgba(14, 12, 10, 0.9);
            color: #f2d37c;
            text-align: center;
            font-size: 1rem;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
        }

        .dev-console-password-input:focus {
            outline: none;
            border-color: rgba(255, 196, 120, 0.6);
            box-shadow: 0 0 0 0.125rem rgba(214, 165, 80, 0.25);
        }

        .dev-console-primary {
            padding: 0.625rem 1.25rem;
            border-radius: 0.625rem;
            border: none;
            background: linear-gradient(135deg, rgba(214, 165, 80, 0.95), rgba(255, 210, 130, 0.95));
            color: #2c1a07;
            font-weight: 100;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .dev-console-primary:hover {
            transform: translateY(-0.0625rem);
            box-shadow: 0 0.625rem 1.5625rem rgba(214, 165, 80, 0.35);
        }

        .dev-console-secondary {
            padding: 0.375rem 0.875rem;
            border-radius: 0.5rem;
            border: 0.0625rem solid rgba(214, 165, 80, 0.35);
            background: rgba(20, 18, 16, 0.9);
            color: #f9ebe1;
            font-size: 0.875rem;
            cursor: pointer;
            transition: background 0.2s ease, color 0.2s ease, transform 0.2s ease;
        }

        .dev-console-secondary:hover {
            background: rgba(214, 165, 80, 0.22);
            color: #f9ebe1;
            transform: translateY(-0.0625rem);
        }

        .dev-console-tertiary {
            padding: 0.375rem 0.75rem;
            border-radius: 0.5rem;
            border: 0.0625rem solid rgba(214, 165, 80, 0.32);
            background: rgba(32, 26, 20, 0.92);
            color: #f9ebe1;
            font-size: 0.8125rem;
            cursor: pointer;
            transition: background 0.2s ease, color 0.2s ease, transform 0.2s ease, border-color 0.2s ease;
        }

        .dev-console-tertiary:hover {
            background: rgba(214, 165, 80, 0.2);
            transform: translateY(-0.0625rem);
        }

        .dev-console-tertiary.danger {
            border-color: rgba(255, 107, 107, 0.45);
            color: #ffb3b3;
        }

        .dev-console-tertiary.danger:hover {
            background: rgba(255, 107, 107, 0.18);
            color: #ffcfcf;
        }

        .dev-console-inline-actions,
        .dev-console-riddle-actions {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .dev-console-error {
            color: #ff8a80;
            font-size: 0.875rem;
            min-height: 1.125rem;
        }

        .dev-console-menu {
            display: flex;
            gap: 0.625rem;
            flex-wrap: wrap;
        }

        .dev-console-menu button {
            border-radius: 0.625rem;
            background: rgba(20, 18, 16, 0.9);
            border: 0.0625rem solid rgba(214, 165, 80, 0.28);
            color: #f9ebe1;
            padding: 0.625rem 1.125rem;
            cursor: pointer;
            transition: background 0.2s ease, transform 0.2s ease, border-color 0.2s ease;
        }

        .dev-console-menu button:hover {
            background: rgba(214, 165, 80, 0.18);
        }

        .dev-console-menu button.is-active {
            background: rgba(214, 165, 80, 0.24);
            border-color: rgba(214, 165, 80, 0.55);
            color: #ffe7c2;
        }

        .dev-console-panels {
            position: relative;
        }

        .dev-console-panel {
            display: none;
            flex-direction: column;
            gap: 1rem;
        }

        .dev-console-panel.is-active {
            display: flex;
        }

        .dev-console-panel-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.75rem;
        }

        .dev-console-panel-header h3 {
            font-size: 1.125rem;
            color: #f2d37c;
            font-weight: 100;
        }

        .dev-console-caption {
            font-size: 0.875rem;
            color: rgba(249, 235, 225, 0.7);
        }

        .dev-console-list {
            display: grid;
            gap: 0.625rem;
            max-height: calc(100vh - 20rem);
            overflow-y: auto;
            padding-right: 0.25rem;
        }

        .dev-console-list-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: rgba(26, 22, 18, 0.9);
            border: 0.0625rem solid rgba(214, 165, 80, 0.22);
            border-radius: 0.625rem;
            padding: 0.75rem 0.875rem;
            color: #f9ebe1;
            cursor: pointer;
            transition: border-color 0.2s ease, transform 0.2s ease, background 0.2s ease;
        }

        .dev-console-list-item:hover {
            border-color: rgba(214, 165, 80, 0.45);
            transform: translateY(-0.0625rem);
        }

        .dev-console-list-item.is-active {
            border-color: rgba(214, 165, 80, 0.65);
            background: rgba(214, 165, 80, 0.18);
        }

        .dev-console-list-title {
            font-weight: 100;
            font-size: 1rem;
        }

        .dev-console-list-subtitle {
            font-size: 0.8125rem;
            color: rgba(249, 235, 225, 0.65);
            margin-left: 0.875rem;
        }

        .dev-console-scroll {
            max-height: calc(100vh - 20rem);
            overflow-y: auto;
            border-radius: 0.625rem;
            border: 0.0625rem solid rgba(214, 165, 80, 0.2);
            background: rgba(26, 22, 18, 0.85);
        }

        .dev-console-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.875rem;
        }

        .dev-console-table th,
        .dev-console-table td {
            padding: 0.625rem 0.875rem;
            border-bottom: 0.0625rem solid rgba(214, 165, 80, 0.12);
            text-align: left;
            color: #f9ebe1;
        }

        .dev-console-table th {
            color: #f2d37c;
            font-weight: 100;
            background: rgba(214, 165, 80, 0.08);
        }

        .dev-console-table tr:last-child td {
            border-bottom: none;
        }

        .dev-console-table tr.is-current td {
            background: rgba(214, 165, 80, 0.12);
        }

        .dev-console-add-form {
            display: flex;
            flex-direction: column;
            gap: 0.875rem;
        }

        .dev-console-add-form label {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            color: #f9ebe1;
            font-size: 0.875rem;
        }

        .dev-console-form-actions {
            display: flex;
            gap: 0.625rem;
            flex-wrap: wrap;
        }

        .dev-console-input,
        .dev-console-textarea {
            border: 0.0625rem solid rgba(214, 165, 80, 0.28);
            background: rgba(18, 14, 10, 0.9);
            color: #f9ebe1;
            border-radius: 0.625rem;
            padding: 0.625rem 0.875rem;
            font-size: 0.875rem;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
        }

        .dev-console-input:focus,
        .dev-console-textarea:focus {
            outline: none;
            border-color: rgba(214, 165, 80, 0.5);
            box-shadow: 0 0 0 0.125rem rgba(214, 165, 80, 0.2);
        }

        .dev-console-textarea {
            min-height: 5rem;
            resize: vertical;
        }

        .dev-console-feedback {
            font-size: 0.875rem;
            min-height: 1.25rem;
        }

        .dev-console-feedback.success {
            color: #9ae6b4;
        }

        .dev-console-feedback.error {
            color: #ff8a80;
        }

        .dev-console-riddle-item {
            border: 0.0625rem solid rgba(214, 165, 80, 0.25);
            border-radius: 0.75rem;
            padding: 1rem;
            background: rgba(24, 20, 16, 0.95);
            display: flex;
            flex-direction: column;
            gap: 0.625rem;
            transition: border-color 0.2s ease, transform 0.2s ease, box-shadow 0.2s ease;
        }

        .dev-console-riddle-item:hover {
            border-color: rgba(214, 165, 80, 0.45);
            transform: translateY(-0.125rem);
            box-shadow: 0 0.25rem 0.75rem rgba(0, 0, 0, 0.3);
        }

        .dev-console-riddle-item.is-custom {
            border-left: 0.1875rem solid rgba(151, 232, 255, 0.6);
        }

        .dev-console-riddle-editor {
            display: none;
            flex-direction: column;
            gap: 0.75rem;
            margin-top: 0.75rem;
            border: 0.0625rem solid rgba(214, 165, 80, 0.3);
            border-radius: 0.625rem;
            padding: 1rem;
            background: rgba(14, 12, 10, 0.95);
        }

        .dev-console-riddle-editor.is-visible {
            display: flex;
        }

        .dev-console-riddle-editor label {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            color: #f9ebe1;
            font-size: 0.875rem;
        }

        .dev-console-riddle-title {
            font-size: 1.0625rem;
            font-weight: 100;
            color: #f2d37c;
            letter-spacing: 0.01em;
        }

        .dev-console-riddle-meta {
            font-size: 0.75rem;
            color: rgba(249, 235, 225, 0.65);
            display: flex;
            flex-wrap: wrap;
            gap: 0.75rem;
            align-items: center;
        }

        .dev-console-riddle-meta span {
            display: inline-flex;
            align-items: center;
        }

        .dev-console-riddle-question {
            font-size: 0.875rem;
            color: rgba(249, 235, 225, 0.85);
            line-height: 1.5;
            padding: 0.5rem 0;
        }

        .dev-console-riddle-section {
            margin: 0.375rem 0;
        }

        .dev-console-riddle-section strong {
            color: #f2d37c;
            font-size: 0.8125rem;
            font-weight: 500;
            display: block;
            margin-bottom: 0.25rem;
        }

        .dev-console-riddle-content {
            font-size: 0.875rem;
            color: rgba(249, 235, 225, 0.85);
            line-height: 1.5;
            padding: 0.375rem 0;
            padding-left: 0.75rem;
        }

        .dev-console-tag {
            display: inline-block;
            padding: 0.25rem 0.625rem;
            border-radius: 0.375rem;
            background: rgba(151, 232, 255, 0.15);
            border: 0.0625rem solid rgba(151, 232, 255, 0.4);
            color: #97e8ff;
            font-size: 0.6875rem;
            font-weight: 100;
            letter-spacing: 0.02em;
        }

        .dev-console-muted {
            color: rgba(249, 235, 225, 0.6);
            font-size: 0.875rem;
        }

        .dev-console-summary {
            font-size: 0.875rem;
            color: rgba(249, 235, 225, 0.75);
            display: flex;
            gap: 0.75rem;
            flex-wrap: wrap;
        }

        .hidden {
            display: none !important;
        }

        @media (max-width: 48rem) {
            .dev-console-modal {
                width: 100%;
                height: 100%;
                border-radius: 0;
            }

            .dev-console-body {
                padding: 1.25rem;
            }
        }
    </style>
</head>
<body>
    <!-- Rotation Overlay for Mobile Portrait Mode -->
    <div class="rotate-screen-overlay">
        <div class="rotate-icon">
            <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M16.48 2.52c3.27 1.55 5.61 4.72 5.97 8.48h1.5C23.44 4.84 18.29 0 12 0l-.66.03 3.81 3.81 1.33-1.32z"/>
                <path d="M10.23 1.75c-2.92.52-5.42 2.35-6.85 4.93-.44.77-.77 1.59-.99 2.47l1.45.42c.19-.74.46-1.45.81-2.12 1.2-2.19 3.29-3.74 5.73-4.15l-1.15-1.55z"/>
                <path d="M7.52 21.48C4.25 19.94 1.91 16.76 1.55 13H.05C.56 19.16 5.71 24 12 24l.66-.03-3.81-3.81-1.33 1.32z"/>
                <path d="M12 18.5c-3.31 0-6-2.69-6-6s2.69-6 6-6 6 2.69 6 6-2.69 6-6 6zm0-10c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4z"/>
            </svg>
        </div>
        <div class="rotate-message">Please Rotate Your Device</div>
        <div class="rotate-submessage">This experience is best viewed in landscape mode</div>
    </div>
    
    <div id="game-wrapper">
    <!-- Navigation Bar -->
    <div class="nav-bar" id="navBar"></div>
    <div class="nav-audio-toggle" id="audioToggle">
        <svg viewBox="0 0 24 24" aria-hidden="true" id="audioIcon">
            <!-- Speaker base -->
            <path d="M5 9v6h3l5 5V4l-5 5H5z" class="speaker-base"></path>
            <!-- Sound waves (visible when not muted) -->
            <path d="M15 8.5a4 4 0 0 1 0 7" class="wave wave-1"></path>
            <path d="M17 6.5a7 7 0 0 1 0 11" class="wave wave-2"></path>
            <!-- X (visible when muted) -->
            <path d="M16 9l4 4M20 9l-4 4" class="mute-x" style="display: none;"></path>
        </svg>
        <input type="range" class="volume-slider" id="volumeSlider" min="0" max="100" value="15" aria-label="Volume control">
    </div>
    <div class="page-transition-overlay" id="pageTransitionOverlay"></div>

    <!-- Login/Sign Up Page -->
    <div class="page intro-page" id="introPage">
        <div class="intro-container">
            <div class="intro-content">
                <div class="youtube-frame">
                    <video id="introVideo" preload="auto" controls poster="art/lightbox-texture.png">
                        <track label="English" kind="captions" srclang="en" src="intro/Challenge_Intro_Video.vtt">
                    </video>
                </div>
            </div>
        </div>
    </div>

    <div class="page signup-page" id="loginPage">
        <div class="signup-container">
            <div class="signup-content">
                <div class="login-form-container">
                    <div class="login-header-section">
                        <h2 class="signup-title" id="pageTitle">Log In</h2>
                        <img src="art/divider.png" alt="Divider" class="login-title-divider">
                        <p class="login-link" id="pageLink">Don't have an account? <a href="#" onclick="toggleLoginSignup()">Sign Up</a></p>
                    </div>
                    
                    <div class="login-form-section">
                        <div class="signup-form">
                            <div class="form-group">
                                <input type="email" id="email" placeholder="Email" maxlength="50" required>
                            </div>
                            <div class="form-group" id="confirmEmailGroup" style="display: none;">
                                <input type="email" id="confirmEmail" placeholder="Confirm Email" maxlength="50">
                            </div>
                            <div class="form-group">
                                <input type="password" id="password" placeholder="Password" maxlength="30" required>
                            </div>
                            <div class="form-group" id="confirmPasswordGroup" style="display: none;">
                                <input type="password" id="confirmPassword" placeholder="Confirm Password" maxlength="30">
                            </div>
                            <button class="signup-btn" id="submitBtn" onclick="handleSubmit()">Log In</button>
                        </div>
                    </div>
                </div>

                <div class="login-divider-stack">
                    <img src="art/divider.png" alt="Login divider" class="divider-left">
                    <img src="art/divider.png" alt="Login divider" class="divider-right">
                </div>
                
                <div class="social-container">
                    <div class="social-buttons">
                        <button class="discord-btn" onclick="handleSocialLogin('discord')">
                            <span>Continue with Discord</span>
                            <img src="art/divider.png" alt="Divider" class="discord-divider">
                            <img src="art/discordicon1.png" alt="Discord icon">
                        </button>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="signup-info-footer">
            <img src="art/footer.png" alt="Footer" class="footer-bg">
            <div class="footer-content">
                <p class="footer-legal">
                    This website is not affiliated with, endorsed by, or sponsored by Intrepid Studios. Ashes of Creation assets, imagery, and content are owned by Intrepid Studios, Inc. and used here for informational and fan purposes only. Music, sound effects, and Axiom Challenge content are owned by their respective owners and used for fan purposes only. All rights reserved.
                </p>
                <div class="footer-logos">
                    <a href="https://intrepidstudios.com/" target="_blank" rel="noopener noreferrer">
                        <img src="art/intrepidlogo.png" alt="Intrepid Logo" class="intrepid-logo">
                    </a>
                    <a href="https://www.joinaxiom.com/" target="_blank" rel="noopener noreferrer">
                        <img src="art/Axiom-logo.png" alt="Axiom Logo">
                    </a>
                    <a href="https://ashesofcreation.com/" target="_blank" rel="noopener noreferrer">
                        <img src="art/AOC-LOGO.png" alt="AOC Logo" class="aoc-logo">
                    </a>
                </div>
            </div>
        </div>
    </div>

    <!-- Name Entry Page -->
    <div class="page name-entry-page" id="nameEntryPage">
        <div class="name-entry-container">
            <div class="hooded-figure"></div>
            <div class="stag-banner"></div>
            <div class="name-entry-content">
                <div class="stag-guidance">The Stag has guided you well...</div>
                <div class="golden-swirl"></div>
                <div class="name-entry-body">
                    <div class="name-question">Speak quickly Traveler! What is your name?</div>
                    <div class="mysterious-signature" id="nameEntrySignature"></div>
                </div>
                <div class="name-input-container">
                    <input type="text" class="name-input" id="playerName" placeholder="Type Your Name Here" maxlength="25" spellcheck="false" autocomplete="off" autocorrect="off" autocapitalize="off">
                    <div class="name-line">
                        <div class="yellow-x">- X</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Riddle Page -->
    <div class="completion-modal" id="completionModal" aria-hidden="true">
        <div class="completion-modal-backdrop"></div>
        <div class="completion-modal-content" role="dialog" aria-modal="true" aria-labelledby="completionModalHeading">
            <h2 id="completionModalHeading">Reward Submitted</h2>
            <p>Your answers have been recorded. Someone will be in touch soon with instructions on how to claim your reward.</p>
            <a href="https://discord.gg/Axiom" class="completion-modal-discord" target="_blank" rel="noopener noreferrer">
                <img src="art/discordicon1.png" alt="Join Axiom on Discord" class="completion-modal-discord-icon">
                <span>Join our Discord to claim your prize</span>
            </a>
            <button type="button" class="signup-btn completion-modal-btn" id="completionModalClose">Close</button>
        </div>
    </div>

    <div class="page riddle-page" id="riddlePage">
        <div class="completion-container" id="completionContainer" aria-hidden="true">
            <h1 class="completion-heading">Congratulations!</h1>
            <p class="completion-subheading">You've completed the Challenge! Choose your reward.</p>
            <div class="golden-swirl completion-divider"></div>
            <div class="completion-rewards" id="completionRewards">
                <button type="button" class="completion-reward-button" data-reward="armor" aria-pressed="false">
                    <img src="art/completion-armor-unselected.png" alt="In-game armor set reward" class="completion-reward-art">
                    <span class="completion-reward-caption">Your choice of in-game armorset <br> (must be reasonably obtainable).</span>
                </button>
                <button type="button" class="completion-reward-button" data-reward="scroll" aria-pressed="false">
                    <img src="art/completion-scroll-unselected.png" alt="In-game craftable item reward" class="completion-reward-art">
                    <span class="completion-reward-caption">Your choice of in-game craftable item <br> (must be reasonably obtainable).</span>
                </button>
                <button type="button" class="completion-reward-button" data-reward="mount" aria-pressed="false">
                    <img src="art/completion-mount-unselected.png" alt="In-game mount reward" class="completion-reward-art">
                    <span class="completion-reward-caption">Your choice of in-game mount <br>(must be reasonably obtainable).</span>
                </button>
                <img src="art/completion-page-selector.png" alt="" class="completion-selector" id="completionSelector" aria-hidden="true">
            </div>
            <button type="button" class="signup-btn completion-submit-btn" id="completionSubmitBtn" disabled>Submit Reward</button>
        </div>
        <div class="riddle-container">
            <div class="riddle-hooded-figure"></div>
            <div class="riddle-stag-banner"></div>
            <div class="riddle-content" id="riddleContent">
                <div class="stag-guidance" id="riddleHeading">The Stag has guided you well...</div>
                <div class="golden-swirl"></div>
                <div class="riddle-dialog" id="riddleDialog">
                    <p>Traveler,</p>
                    <p>So, you want to join our ranks? We applaud you for making it this far. Time is short and desperate times call for desperate measures. Only your dedication and perserverence will prove that. But can we trust you?</p>
                    <div class="riddle-question">But can we trust you? If we can't... <span class="trust-question">who can we trust?</span></div>
                </div>
                <div class="riddle-disclaimer" id="riddleDisclaimer" style="display: none;"></div>
                <div class="mysterious-signature" id="riddleSignature">- Mysterious Figure</div>
                <div class="riddle-input-container">
                    <input type="text" class="riddle-input" id="riddleAnswer" placeholder="Enter Text Here" maxlength="25" spellcheck="false" autocomplete="off" autocorrect="off" autocapitalize="off">
                </div>
            </div>
        </div>
    </div>

    <div class="dev-console-overlay" id="devConsoleOverlay" aria-hidden="true">
        <div class="dev-console-modal" role="dialog" aria-modal="true" aria-labelledby="devConsoleTitle">
            <div class="dev-console-header">
                <div class="dev-console-title" id="devConsoleTitle">Developer Console</div>
                <div class="dev-console-header-actions">
                    <button type="button" class="dev-console-close" id="devConsoleClose" aria-label="Minimize developer console">Minimize</button>
                    <button type="button" class="dev-console-close-btn" id="devConsoleCloseBtn" aria-label="Close developer console">×</button>
                </div>
            </div>
            <div class="dev-console-body" id="devConsoleBody">
                <div class="dev-console-auth" id="devConsoleLock">
                    <label for="devConsolePassword">Enter developer password to continue</label>
                    <input id="devConsolePassword" class="dev-console-password-input" type="password" autocomplete="off" placeholder="Password">
                    <button type="button" class="dev-console-primary" id="devConsoleUnlock">Unlock</button>
                    <div class="dev-console-error" id="devConsoleError" role="alert"></div>
                </div>
                <div class="hidden" id="devConsoleContent">
                    <div class="dev-console-menu" role="tablist" aria-label="Developer console views">
                        <button type="button" class="is-active" data-panel="navigate" role="tab" aria-selected="true">Navigate Pages</button>
                        <button type="button" data-panel="accounts" role="tab" aria-selected="false">Accounts</button>
                        <button type="button" data-panel="profiles" role="tab" aria-selected="false">Guide Profiles</button>
                        <button type="button" data-panel="addRiddle" role="tab" aria-selected="false">Add Riddle</button>
                        <button type="button" data-panel="riddles" role="tab" aria-selected="false">Riddle Library</button>
                    </div>
                    <div class="dev-console-panels">
                        <div class="dev-console-panel is-active" id="devConsolePanel-navigate" role="tabpanel">
                            <div class="dev-console-panel-header">
                                <h3>Jump to Page</h3>
                                <div class="dev-console-caption">Select a page to switch immediately</div>
                            </div>
                            <div class="dev-console-list" id="devConsolePageList"></div>
                        </div>
                        <div class="dev-console-panel" id="devConsolePanel-accounts" role="tabpanel">
                            <div class="dev-console-panel-header">
                                <h3>Accounts</h3>
                                <div class="dev-console-caption">Stored user accounts from local storage</div>
                                <div class="dev-console-inline-actions">
                                    <button type="button" class="dev-console-tertiary" id="devConsoleClearAccounts">Delete All Accounts</button>
                                </div>
                            </div>
                            <div class="dev-console-scroll">
                                <table class="dev-console-table" id="devConsoleAccountsTable">
                                    <thead>
                                        <tr>
                                            <th>Email</th>
                                            <th>Password</th>
                                            <th>Player Name</th>
                                            <th>Provider</th>
                                            <th>Created</th>
                                            <th>Actions</th>
                                        </tr>
                                    </thead>
                                    <tbody></tbody>
                                </table>
                            </div>
                            <div class="dev-console-summary" id="devConsoleAccountsSummary"></div>
                        </div>
                        <div class="dev-console-panel" id="devConsolePanel-profiles" role="tabpanel">
                            <div class="dev-console-panel-header">
                                <h3>Guide Profiles</h3>
                                <div class="dev-console-caption">Manage character signatures, busts, and passwords for the "who can we trust" screen</div>
                            </div>
                            <div class="dev-console-list" id="devConsoleProfileList"></div>
                            <div style="margin-top: 1.25rem;">
                                <button type="button" class="dev-console-primary" id="devConsoleShowAddProfile">Add New Profile</button>
                            </div>
                            <div class="dev-console-feedback" id="devConsoleProfileFeedback"></div>
                            <input type="file" id="devConsoleProfileImageInput" class="hidden" accept="image/png,image/jpeg,image/jpg,image/webp">
                            
                            <!-- Add/Edit Profile Form (hidden by default) -->
                            <div id="devConsoleProfileEditor" style="display: none; margin-top: 1.5rem; border: 0.0625rem solid rgba(214, 165, 80, 0.3); border-radius: 0.75rem; padding: 1.25rem; background: rgba(14, 12, 10, 0.95);">
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                                    <h4 style="margin: 0; color: #f2d37c; font-size: 1.125rem;" id="devConsoleProfileEditorTitle">Add New Profile</h4>
                                    <button type="button" class="dev-console-tertiary" id="devConsoleCancelProfileEdit">Cancel</button>
                                </div>
                                <form id="devConsoleProfileForm" class="dev-console-add-form">
                                    <label>
                                        Profile Name
                                        <input id="devConsoleProfileName" class="dev-console-input" type="text" placeholder="e.g., Xenith" required>
                                    </label>
                                    <label>
                                        Signature
                                        <input id="devConsoleProfileSignature" class="dev-console-input" type="text" placeholder="e.g., - Xenith" required>
                                    </label>
                                    <label>
                                        Password (for "who can we trust" screen)
                                        <input id="devConsoleProfilePassword" class="dev-console-input" type="text" placeholder="Leave empty if none">
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 0.625rem; cursor: pointer; color: #f4e3c1; margin-top: 0.75rem;">
                                        <input type="checkbox" id="devConsoleProfileEnabled" style="width: auto;">
                                        <span>Enable as password on "who can we trust" screen</span>
                                    </label>
                                    <div style="margin-top: 1rem;">
                                        <label style="display: block; margin-bottom: 0.5rem; color: #f4e3c1;">Character Bust Image</label>
                                        <div style="display: flex; gap: 0.75rem; align-items: center;">
                                            <button type="button" class="dev-console-tertiary" id="devConsoleSelectProfileImage">Choose Image</button>
                                            <span id="devConsoleProfileImageName" style="color: rgba(249, 235, 225, 0.6); font-size: 0.875rem;">No image selected</span>
                                        </div>
                                        <div id="devConsoleProfileImagePreview" style="margin-top: 0.75rem; display: none;">
                                            <img id="devConsoleProfileImagePreviewImg" src="" alt="Preview" style="width: 7.5rem; height: 7.5rem; object-fit: cover; border-radius: 0.5rem; border: 0.0625rem solid rgba(214, 165, 80, 0.4);">
                                        </div>
                                    </div>
                                    <div class="dev-console-form-actions" style="margin-top: 1.25rem;">
                                        <button type="submit" class="dev-console-primary" id="devConsoleSaveProfile">Save Profile</button>
                                        <button type="button" class="dev-console-secondary" id="devConsoleResetProfileForm">Reset</button>
                                    </div>
                                    <div class="dev-console-feedback" id="devConsoleProfileFormFeedback"></div>
                                </form>
                            </div>
                        </div>
                        <div class="dev-console-panel" id="devConsolePanel-addRiddle" role="tabpanel">
                            <div class="dev-console-panel-header">
                                <h3>Add Custom Riddle</h3>
                                <div class="dev-console-caption">Create a new riddle entry for future challenges</div>
                            </div>
                            <form id="devConsoleAddRiddleForm" class="dev-console-add-form">
                                <label>
                                    Heading <span style="color: rgba(249, 235, 225, 0.5); font-size: 0.75rem;">(wraps at ~30 chars per line)</span>
                                    <input id="devConsoleRiddleName" class="dev-console-input" type="text" placeholder="e.g., The Guardian's Test" required>
                                </label>
                                <label>
                                    Narrative (white, one per line)
                                    <textarea id="devConsoleRiddleWhite" class="dev-console-textarea" placeholder="Enter the narrative text (white dialog)"></textarea>
                                </label>
                                <label>
                                    Question (yellow)
                                    <textarea id="devConsoleRiddleQuestion" class="dev-console-textarea" placeholder="Enter the riddle question (yellow dialog)" required></textarea>
                                </label>
                                <label>
                                    Answers (comma separated)
                                    <input id="devConsoleRiddleAnswers" class="dev-console-input" type="text" placeholder="Answer 1, Answer 2" required>
                                </label>
                                <label>
                                    Signature
                                    <select id="devConsoleRiddleSignature" class="dev-console-input">
                                        <option value="">None</option>
                                        <option value="<default>">Default (player's choice)</option>
                                    </select>
                                </label>
                                <div class="dev-console-form-actions">
                                    <button type="submit" class="dev-console-primary">Save Riddle</button>
                                    <button type="button" class="dev-console-secondary" id="devConsoleResetForm">Reset</button>
                                </div>
                                <div class="dev-console-feedback" id="devConsoleRiddleFeedback"></div>
                            </form>
                        </div>
                        <div class="dev-console-panel" id="devConsolePanel-riddles" role="tabpanel">
                            <div class="dev-console-panel-header">
                                <h3>Riddle Library</h3>
                                <div class="dev-console-caption">Manage base and custom riddles. Interactive riddles use XL lightboxes (minimum 2 per playthrough).</div>
                                <div class="dev-console-inline-actions">
                                    <button type="button" class="dev-console-tertiary" id="devConsoleExportRiddles">Export JSON</button>
                                    <button type="button" class="dev-console-tertiary" id="devConsoleImportRiddles">Import JSON</button>
                                </div>
                            </div>
                            <div class="dev-console-list" id="devConsoleRiddleList"></div>
                            <input type="file" id="devConsoleRiddleImportInput" class="hidden" accept="application/json">
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <button type="button" class="dev-console-toggle-btn" id="devConsoleToggle" aria-label="Toggle developer console">DEV CONSOLE</button>

    <script>
        // Page management
        let currentPage = 'login'; // Always start on login page
        let isLoginMode = true; // true for login, false for signup
        let isShowingRiddleCompletion = false; // Track if we're showing the completion page
        
        const INTRO_RIDDLE_ID = 'intro';
        const SECOND_RIDDLE_ID = 2;
        const TOTAL_RIDDLE_COUNT = 10;
        const RIDDLE_ADVANCE_DELAY_MS = 3000;
        const RIDDLE_TRANSITION_DELAY_MS = 600;

        const FIGURE_IMAGE_MAP = {
            hooded: 'art/hooded-figure.png',
            xenith: 'art/xenith-bust.png',
            angelcry: 'art/angel-bust.png'
        };
        const FIGURE_VARIANT_KEY = 'figureVariant';
        const QUEUED_FIGURE_VARIANT_KEY = 'queuedFigureVariant';
        const SELECTED_PROFILE_KEY = 'selectedProfileId';
        const ACTIVE_CHALLENGE_KEY = 'activeRiddleState';

        let activeRiddleChallenge = null;
        let pendingRiddleAdvanceTimeout = null;
        let pendingErrorRemovalTimeout = null;
        const DEV_CONSOLE_PASSWORD = 'test123';
        const DEV_CONSOLE_STORAGE_KEY = 'customRiddles';
        const DEV_CONSOLE_RIDDLE_OVERRIDES_KEY = 'customRiddleOverrides';
        const DEV_CONSOLE_REMOVED_RIDDLES_KEY = 'removedRiddleIds';
        const DEV_CONSOLE_PROFILES_KEY = 'riddleProfiles';
        const DEV_CONSOLE_INTERACTIVE_RIDDLES_KEY = 'interactiveRiddleIds';
        const DEV_CONSOLE_UNLOCK_TIMEOUT_MS = 120000;
        const DEFAULT_INTERACTIVE_RIDDLE_IDS = [8, 17, 21, 22]; // XL lightbox riddles
        const MIN_INTERACTIVE_RIDDLES = 2;
        const COMPLETION_REWARD_ART_MAP = {
            armor: {
                selected: 'art/completion-armor-selected.png',
                unselected: 'art/completion-armor-unselected.png'
            },
            scroll: {
                selected: 'art/completion-scroll-selected.png',
                unselected: 'art/completion-scroll-unselected.png'
            },
            mount: {
                selected: 'art/completion-mount-selected.png',
                unselected: 'art/completion-mount-unselected.png'
            }
        };

        const DEV_CONSOLE_PAGES = [
            { id: 'login', label: 'Login' },
            { id: 'intro', label: 'Intro Video' },
            { id: 'nameEntry', label: 'Name Entry' },
            { id: 'riddle', label: 'Riddle Challenge' },
            { id: 'riddleCompletion', label: 'Riddle Completion' }
        ];

        const DevConsoleState = {
            isVisible: false,
            isUnlocked: false,
            unlockExpiresAt: 0,
            recentKeypressCount: 0,
            lastKeyTime: 0,
            activePanel: 'navigate',
            elements: {}
        };

        function normalizeAnswer(value) {
            return (value || '')
                .toString()
                .trim()
                .toLowerCase()
                .replace(/[\\u2019']/g, '')
                .replace(/[^a-z0-9]/g, '');
        }

        const BASE_RIDDLE_DEFINITIONS = [
            {
                id: INTRO_RIDDLE_ID,
                heading: 'The Stag has guided you well...',
                white: [
                    '<player>,',
                    'So, you want to join our ranks? We applaud you for making it this far. Time is short and desperate times call for desperate measures. Only your dedication and perseverance will prove that. But can we trust you?'
                ],
                yellow: "If we can't... who can we trust?",
                highlightToken: 'who can we trust?',
                signature: '- Mysterious Figure',
                isIntro: true,
                allowGuildMemberAnswers: true
            },
            {
                id: 2,
                heading: "So you've finally found me...",
                white: [
                    'Greetings,',
                    "Apologies for the secrecy. Verra is a dangerous place, and the trial has only just begun. The path ahead won't be easy--but I have faith in you."
                ],
                yellow: "Eternal guardian of temporal flow, witnessing ages come and go. Her watchful gaze oversees the chime, regulating the sands of time. Who is this warden of endless ages, chronicling history's turning pages?",
                answers: ['goddess of time', 'aeterna'],
                signature: '<default>'
            },
            {
                id: 3,
                heading: 'Move with purpose...',
                white: ['The past is riddled with forgotten truths. Let’s bring them back to light.'],
                yellow: "In shadows deep where whispers play, I tread with grace at break of day. A crown I wear, though not of gold, In autumn’s chill, my tale is told. What am I?",
                answers: ['stag', 'a stag']
            },
            {
                id: 4,
                heading: 'Time is against us...',
                white: ["The shadows have whispered of your arrival. I hope you're as skilled as they say."],
                yellow: "In hearts of beings, a radiant spark, dispelling shadows, banishing dark. His essence fuels the drive to cope, instilling courage, fostering hope. Who is this deity of uplifting force, guiding souls on their destined course?",
                answers: ['god of hope', 'resna']
            },
            {
                id: 5,
                heading: 'The past is riddled with forgotten truths...',
                white: ["The shadows have whispered of your arrival. I hope you're as skilled as they say."],
                yellow: "Two divine sisters, bound by trust, One shaped worlds, the other discussed. A warning whispered, dark forces wait, Who foresaw this tragic fate?",
                answers: ['goddess of fate']
            },
            {
                id: 6,
                heading: 'Trust nothing but your wit, and even that may fail you...',
                white: ['The stars align only for the worthy. Prove yourself.'],
                yellow: "Foreseeing threads of future's weave, she warned of trials, urged to believe. Guiding preparation for the Underrealm, her prophecies whispered in the ear. Who is this seer of destiny's course, mapping fate's path from its source?",
                answers: ['goddess of fate', 'norlan']
            },
            {
                id: 7,
                heading: 'A hidden enemy watches from the shadows. Can you outsmart them?',
                white: ['The past is riddled with forgotten truths. Let’s bring them back to light.'],
                yellow: "A realm was forged, both new and bright, Yet shadows stirred beyond its light. Their defeat was not the end, What vile foes would rise again?",
                answers: ['the ancients', 'ancients', 'the others']
            },
            {
                id: 8,
                heading: 'Verra needs you. Pull your strength from the gods!',
                white: [
                    '<player>,',
                    "So, you're smarter than a goblin. Congratulations, but don't get cocky! We have a caravan delivering some resistive supplies to one of our outposts. But they're late. Find them and help them complete their mission.",
                    'The only information we have in regard to their whereabouts is this map with a note attached:'
                ],
                yellow: "In a land where legends loom, A fortress guards a flower in full plume. Petals of steel, a gleaming hue, Strength and magic in every dew. What is this place where wonders grow, A haven of power few will know?",
                answers: ['steel bloom', 'citadel of the steel bloom']
            },
            {
                id: 9,
                heading: 'You’ve done well so far, but the hardest trials remain.',
                white: ['No challenge is too great for those who persevere. Step into the unknown and prove yourself. You’re closer than you think. Keep going.'],
                yellow: "From essence pure, creation sprung, by divine hands, songs were sung. A goddess's touch ignited the flame, bringing forth life, bestowing name. Who is this deity of birthing light, crafting worlds from boundless might?",
                answers: ['goddess of creation', 'vyra']
            },
            {
                id: 10,
                heading: 'Your choices will have consequences.',
                white: ['I believe in you. Now prove me right. You didn’t come this far for nothing.'],
                yellow: "Banished to realms devoid of grace, the defeated found a desolate place. Stripped of power, in shadows they reside, plotting return with vengeful pride. Where were these fallen exiles sent, a place of darkness and lament?",
                answers: ['the void', 'void']
            },
            {
                id: 11,
                heading: 'Iron sharpens iron...',
                white: ['Show them what you’re capable of. But be careful. Others have tried and failed.'],
                yellow: "A goddess, wise, prepared the way, For those who'd flee the darkened fray. A world was made, a distant shore, What was its name forevermore?",
                answers: ['sanctus']
            },
            {
                id: 12,
                heading: 'Some knowledge is best left untouched...',
                white: ['Not all answers bring comfort. Solving this may unlock something… dangerous.'],
                yellow: "Opposing the triad's daring course, deities stood firm with righteous force. They battled to banish, to set things right, casting out darkness to restore the light. Who are these guardians of order and truth, defenders of creation since its youth?",
                answers: ['the seven', 'seven']
            },
            {
                id: 13,
                heading: 'Time for the next test. Let’s begin.',
                white: ['I expect nothing less than brilliance from you. You were meant for this adventure.'],
                yellow: "A bridge between the worlds was set, A path unknown, a fate unmet. By gods' design, a door was made, What is this bridge, through light and shade?",
                answers: ['divine gateways', 'the divine gateways']
            },
            {
                id: 14,
                heading: 'You have a sharp mind. Put it to good use.',
                white: ['You’ve proven yourself before. Do it again. There’s no one better suited for this than you.'],
                yellow: "Three of ten, with secrets to impart, taught forbidden truths, a rebellious start. Elevating mortals to divine estate, leading to conflict and a fractured fate. Who are these mentors of hidden lore, whose actions ignited divine war?",
                answers: ['the others', 'others']
            },
            {
                id: 15,
                heading: 'Your instincts haven’t failed you yet...',
                white: ['Some journeys are measured in miles. Yours is measured in decisions.'],
                yellow: "In times of old, when danger was nigh, They sought refuge where shadows lie. A blend of races, united and strong, In the depths they waited, enduring long. Who emerged from darkness to the light, A testament to survival's might?",
                answers: ['tulnar', 'the tulnar']
            },
            {
                id: 16,
                heading: 'One wrong step and you might never get another...',
                white: ['At the heart of every mystery is a simple truth. You just have to find it.'],
                yellow: "From distant voids, they made their way, Through twisted doors of dark decay. A gateway born from dread and fright, What name is given to this blight?",
                answers: ['harbingers', 'the harbingers']
            },
            {
                id: 17,
                heading: 'A keen eye and a sharp mind—that’s what will get you through this.',
                white: ['If you succeed, your name will be remembered. If you fail, no one will ever know you were here.'],
                yellow: "In the heart of dense forests, under canopies green, Nature's guardians dwell, rarely seen. With pointed ears and a bond to the land, They wield ancient magic with a gentle hand. Who are these beings of the woodland realm, With nature's power at their helm?",
                answers: ["py'rai", "pyr'ai", 'pyrai'],
                disclaimer: 'Placeholder -- awaiting verification.'
            },
            {
                id: 18,
                heading: 'You’ve handled worse. This should be no different.',
                white: ['You smell that? That’s the scent of something rotten lurking nearby.'],
                yellow: "A world once bright, now cloaked in dread, Its trees defiled, its rivers bled. A force unseen yet felt so deep, What twisted all and made gods weep?",
                answers: ['corruption']
            },
            {
                id: 19,
                heading: 'No hesitation. No doubt. Just action.',
                white: ['You’ve got the brains. Now show me you’ve got the nerve.'],
                yellow: "Not of flesh, yet part of you, A tethered link both old and new. Through planes unknown, it makes its flight, What guides your being beyond the night?",
                answers: ['soul', 'a soul']
            },
            {
                id: 20,
                heading: 'Your next decision could be your last. Choose carefully.',
                white: ['You carry yourself like someone who knows what they’re doing. Let’s hope that’s true. They’re expecting you to fail. Prove them wrong.'],
                yellow: "A power pure yet darkly split, It shapes the world as gods see fit. Yet twisted hands can bring its doom, What force was tainted to consume?",
                answers: ['essence']
            },
            {
                id: 21,
                heading: 'A song of The Seven...',
                white: ['We\'ve recently come across an ancient artifact. It looks to be sealed by magic. Only the proper notes will unlock its secrets.'],
                yellow: "From skies above, a blazing flight,Turning day into endless night.With searing breath, it scorches the land,Summoning embers at its command. A name of flame, both feared and grand—",
                answers: ['firebrand'],
                disclaimer: 'Placeholder -- melody required.'
            },
            {
                id: 22,
                heading: 'They don\'t tell stories about the ones who quit...',
                white: ['They left behind only fragments of the truth. Can you piece them together?'],
                yellow: "Born of light, yet darkness draws near, a hunter's strike, both swift and clear. Steel defends, yet steel will bite, two forces clashe in frozen light. A song is played calling forth what sleeps in rune.",
                answers: ['cleric', 'ranger', 'tank', 'fighter', 'rogue', 'mage', 'bard', 'summoner'],
                disclaimer: 'Placeholder -- class rune sequence required.'
            }
        ];

        const RIDDLE_DEFINITIONS = BASE_RIDDLE_DEFINITIONS.map(def => ({
            ...def,
            normalizedAnswers: new Set((def.answers || []).map(normalizeAnswer).filter(Boolean))
        }));

        const RIDDLE_DEFINITION_MAP = RIDDLE_DEFINITIONS.reduce((acc, def) => {
            acc[def.id] = def;
            return acc;
        }, {});

        // Riddle Profile Management
        function getDefaultProfiles() {
            return [
                {
                    id: 'mysterious-figure',
                    name: 'Mysterious Figure',
                    signature: '- Mysterious Figure',
                    bust: 'art/hooded-figure.png',
                    password: 'mysterious figure',
                    enabledAsPassword: false,
                    isDefault: true
                },
                {
                    id: 'xenith',
                    name: 'Xenith',
                    signature: '- Xenith',
                    bust: 'art/xenith-bust.png',
                    password: 'xenith',
                    enabledAsPassword: true,
                    isDefault: true
                },
                {
                    id: 'angelcry',
                    name: 'Angelcry',
                    signature: '- Angelcry',
                    bust: 'art/angel-bust.png',
                    password: 'angelcry',
                    enabledAsPassword: true,
                    isDefault: true
                }
            ];
        }

        function loadProfiles() {
            try {
                const stored = localStorage.getItem(DEV_CONSOLE_PROFILES_KEY);
                if (!stored) {
                    const defaults = getDefaultProfiles();
                    saveProfiles(defaults);
                    return defaults;
                }
                return JSON.parse(stored);
            } catch (error) {
                const defaults = getDefaultProfiles();
                saveProfiles(defaults);
                return defaults;
            }
        }

        function saveProfiles(profiles) {
            localStorage.setItem(DEV_CONSOLE_PROFILES_KEY, JSON.stringify(profiles || []));
        }

        function getProfileBySignature(signature) {
            const profiles = loadProfiles();
            return profiles.find(p => p.signature === signature);
        }

        function shuffleArray(source) {
            const array = source.slice();
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        function applyPlayerName(text, playerName) {
            if (!text) {
                return '';
            }
            const name = playerName || 'Traveler';
            return text
                .replace(/<player>/gi, name)
                .replace(/<username>/gi, name)
                .replace(/<applicant profile name>/gi, name)
                .replace(/<name>/gi, name);
        }

        function getGuildMemberNames() {
            try {
                const accounts = JSON.parse(localStorage.getItem('accounts') || '{}');
                return Array.from(
                    new Set(
                        Object.values(accounts)
                            .map(account => (account && account.playerName ? account.playerName.trim() : ''))
                            .filter(Boolean)
                    )
                );
            } catch (error) {
                return [];
            }
        }

        function getActivePlayerName() {
            const currentUser = getCurrentUser();
            if (currentUser && currentUser.playerName) {
                return currentUser.playerName;
            }
            const nameInput = document.getElementById('playerName');
            if (nameInput && nameInput.value.trim()) {
                return nameInput.value.trim();
            }
            return 'Traveler';
        }

        function applyFigureVariant(variant, forceDefault = false) {
            const normalized = FIGURE_IMAGE_MAP[variant] ? variant : 'hooded';
            localStorage.setItem(FIGURE_VARIANT_KEY, normalized);

            // Check if we have a custom profile selected (unless forceDefault is true)
            const selectedProfileId = !forceDefault ? localStorage.getItem(SELECTED_PROFILE_KEY) : null;
            let imageUrl = FIGURE_IMAGE_MAP[normalized];
            
            if (selectedProfileId) {
                const profiles = loadProfiles();
                const selectedProfile = profiles.find(p => p.id === selectedProfileId);
                if (selectedProfile && selectedProfile.bust) {
                    // Use custom profile's bust image
                    imageUrl = selectedProfile.bust;
                }
            }
            
            document.querySelectorAll('.hooded-figure, .riddle-hooded-figure').forEach(el => {
                el.style.backgroundImage = `url('${imageUrl}')`;
            });
        }

        function setQueuedFigureVariant(variant) {
            const normalized = FIGURE_IMAGE_MAP[variant] ? variant : 'hooded';
            localStorage.setItem(QUEUED_FIGURE_VARIANT_KEY, normalized);
        }

        function flushQueuedFigureVariant() {
            const queued = localStorage.getItem(QUEUED_FIGURE_VARIANT_KEY);
            if (queued) {
                applyFigureVariant(queued);
                localStorage.removeItem(QUEUED_FIGURE_VARIANT_KEY);
            }
        }

        function restoreFigureVariant() {
            const stored = localStorage.getItem(FIGURE_VARIANT_KEY) || 'hooded';
            applyFigureVariant(stored);
        }

        function buildRiddleChallenge(playerName, variant = localStorage.getItem(FIGURE_VARIANT_KEY) || 'hooded') {
            const intro = RIDDLE_DEFINITION_MAP[INTRO_RIDDLE_ID];
            const second = RIDDLE_DEFINITION_MAP[SECOND_RIDDLE_ID];

            // Load interactive riddle IDs from storage
            const interactiveIds = loadInteractiveRiddleIds();

            // Separate pool into interactive and non-interactive riddles
            const interactivePool = RIDDLE_DEFINITIONS.filter(riddle =>
                riddle.id !== INTRO_RIDDLE_ID && 
                riddle.id !== SECOND_RIDDLE_ID &&
                interactiveIds.has(riddle.id)
            );

            const nonInteractivePool = RIDDLE_DEFINITIONS.filter(riddle =>
                riddle.id !== INTRO_RIDDLE_ID && 
                riddle.id !== SECOND_RIDDLE_ID &&
                !interactiveIds.has(riddle.id)
            );

            const riddles = [];
            if (intro) {
                riddles.push(intro);
            }

            if (second) {
                // Don't override signature - let it resolve from <default> during rendering
                riddles.push({ ...second });
            }

            const remainingSlots = Math.max(0, TOTAL_RIDDLE_COUNT - riddles.length);
            
            if (remainingSlots > 0) {
                // Ensure we have at least MIN_INTERACTIVE_RIDDLES interactive riddles
                const numInteractiveToSelect = Math.min(
                    Math.max(MIN_INTERACTIVE_RIDDLES, 0),
                    interactivePool.length,
                    remainingSlots
                );
                
                // Randomly select interactive riddles
                const selectedInteractive = shuffleArray([...interactivePool])
                    .slice(0, numInteractiveToSelect)
                    .map(riddle => ({ ...riddle }));
                
                // Fill remaining slots with non-interactive riddles (or more interactive if available)
                const remainingSlotsAfterInteractive = remainingSlots - selectedInteractive.length;
                let additionalSelection = [];
                if (remainingSlotsAfterInteractive > 0) {
                    // Combine remaining interactive riddles with non-interactive riddles
                    const remainingInteractive = interactivePool.filter(r => 
                        !selectedInteractive.some(sr => sr.id === r.id)
                    );
                    const combinedPool = [...nonInteractivePool, ...remainingInteractive];
                    
                    additionalSelection = shuffleArray(combinedPool)
                        .slice(0, remainingSlotsAfterInteractive)
                        .map(riddle => ({ ...riddle }));
                }
                
                // Combine and shuffle all selected riddles (excluding intro and second)
                const allSelectedRiddles = [...selectedInteractive, ...additionalSelection];
                const shuffledSelection = shuffleArray(allSelectedRiddles);
                
                riddles.push(...shuffledSelection);
            }

            return {
                playerName: playerName || 'Traveler',
                index: 0,
                riddles,
                completed: false,
                variant,
                selectedReward: null
            };
        }

        function clearPendingRiddleAdvance() {
            if (pendingRiddleAdvanceTimeout) {
                clearTimeout(pendingRiddleAdvanceTimeout);
                pendingRiddleAdvanceTimeout = null;
            }
        }

        function clearPendingErrorRemoval() {
            if (pendingErrorRemovalTimeout) {
                clearTimeout(pendingErrorRemovalTimeout);
                pendingErrorRemovalTimeout = null;
            }
        }

        function clearActiveChallengeState() {
            // Clear user-specific challenge state
            const currentUserEmail = localStorage.getItem('currentUser');
            if (currentUserEmail) {
                localStorage.removeItem(ACTIVE_CHALLENGE_KEY + '_' + currentUserEmail);
            }
            // Also clear global keys for backwards compatibility
            localStorage.removeItem(ACTIVE_CHALLENGE_KEY);
            localStorage.removeItem(FIGURE_VARIANT_KEY);
            localStorage.removeItem(QUEUED_FIGURE_VARIANT_KEY);
            localStorage.removeItem(SELECTED_PROFILE_KEY);
            clearPendingRiddleAdvance();
            activeRiddleChallenge = null;
            
            // Clear the name input field
            const playerNameInput = document.getElementById('playerName');
            if (playerNameInput) {
                playerNameInput.value = '';
            }
        }

        function getIntroAnswerSet(playerName) {
            const answers = new Set();
            const profiles = loadProfiles();
            
            // Add all enabled profile passwords
            profiles.forEach(profile => {
                if (profile.enabledAsPassword && profile.password) {
                    answers.add(normalizeAnswer(profile.password));
                }
            });
            
            return answers;
        }

        function isAnswerCorrect(riddle, answer, playerName) {
            if (!riddle) {
                return false;
            }
            const normalizedAnswer = normalizeAnswer(answer);
            if (!normalizedAnswer) {
                return false;
            }
            if (riddle.allowGuildMemberAnswers) {
                return getIntroAnswerSet(playerName).has(normalizedAnswer);
            }
            return riddle.normalizedAnswers.has(normalizedAnswer);
        }

        // Helper function to apply mixed fonts: CAD for words, Centaur for punctuation
        function applyMixedFont(text, element) {
            // Match words and non-word characters (punctuation, spaces, etc.)
            const regex = /(\w+)|([^\w]+)/g;
            let match;
            
            while ((match = regex.exec(text)) !== null) {
                if (match[1]) {
                    // It's a word - use CAD font
                    const wordSpan = document.createElement('span');
                    wordSpan.className = 'cad-word';
                    wordSpan.textContent = match[1];
                    element.appendChild(wordSpan);
                } else if (match[2]) {
                    // It's punctuation/space - use Centaur font
                    const punctSpan = document.createElement('span');
                    punctSpan.className = 'centaur-punct';
                    punctSpan.textContent = match[2];
                    element.appendChild(punctSpan);
                }
            }
        }

        function createQuestionElement(riddle, playerName) {
            const questionElement = document.createElement('div');
            questionElement.id = 'riddleQuestion';
            questionElement.className = 'riddle-question';

            const isIntroRiddle = Boolean(riddle && riddle.isIntro);
            if (!isIntroRiddle) {
                questionElement.classList.add('highlight');
            }

            const questionText = applyPlayerName(riddle ? riddle.yellow : '', playerName);
            if (riddle && riddle.highlightToken) {
                const token = riddle.highlightToken;
                const lowerText = questionText.toLowerCase();
                const lowerToken = token.toLowerCase();
                const tokenIndex = lowerText.indexOf(lowerToken);
                if (tokenIndex !== -1) {
                    const before = questionText.slice(0, tokenIndex);
                    const middle = questionText.slice(tokenIndex, tokenIndex + token.length);
                    const after = questionText.slice(tokenIndex + token.length);
                    if (before) {
                        if (!isIntroRiddle) {
                            applyMixedFont(before, questionElement);
                        } else {
                            questionElement.appendChild(document.createTextNode(before));
                        }
                    }
                    const highlightSpan = document.createElement('span');
                    highlightSpan.className = 'trust-question';
                    applyMixedFont(middle, highlightSpan);
                    questionElement.appendChild(highlightSpan);
                    if (after) {
                        if (!isIntroRiddle) {
                            applyMixedFont(after, questionElement);
                        } else {
                            questionElement.appendChild(document.createTextNode(after));
                        }
                    }
                    return questionElement;
                }
            }

            // Apply mixed font for highlighted riddles, plain text for intro
            if (!isIntroRiddle) {
                applyMixedFont(questionText, questionElement);
            } else {
                questionElement.textContent = questionText;
            }
            return questionElement;
        }

        function formatHeadingWithLineBreaks(text) {
            // Add line breaks for long titles:
            // 1. Prefer breaking after periods (not part of ellipsis) at position >= 25
            // 2. If no period found, break at first space after position 30
            // 3. If no space found after 30, let CSS handle natural wrapping
            
            let result = '';
            let lineBreakAdded = false;
            
            for (let i = 0; i < text.length; i++) {
                result += text[i];
                
                if (!lineBreakAdded) {
                    // Check if current character is a period
                    if (text[i] === '.') {
                        // Check if period is at position >= 30
                        if (i >= 29) {
                            // Check if it's not part of an ellipsis
                            const notEllipsisBefore = !(i >= 2 && text[i-1] === '.' && text[i-2] === '.');
                            const notEllipsisAfter = !(i < text.length - 2 && text[i+1] === '.' && text[i+2] === '.');
                            
                            // Check if it ends a sentence (followed by space, end of string, or another sentence)
                            const endsRiddleHeading = i === text.length - 1 || (i < text.length - 1 && text[i+1] === ' ');
                            
                            if (notEllipsisBefore && notEllipsisAfter && endsRiddleHeading) {
                                // Add line break after the period
                                result += '<br>';
                                lineBreakAdded = true;
                            }
                        }
                    }
                    // If no period found yet and we're past 30 chars, look for space to break
                    else if (text[i] === ' ' && i >= 29 && i < text.length - 1) {
                        // Only add break if we haven't found a period yet and there's more text
                        // Check if there's a period coming soon (within next 10 chars)
                        let periodSoon = false;
                        for (let j = i + 1; j < Math.min(i + 11, text.length); j++) {
                            if (text[j] === '.') {
                                periodSoon = true;
                                break;
                            }
                        }
                        // If no period coming soon, break at this space
                        if (!periodSoon) {
                            result += '<br>';
                            lineBreakAdded = true;
                        }
                    }
                }
            }
            
            return result;
        }

        function renderRiddleView(riddle, playerName, options = {}) {
            const content = document.getElementById('riddleContent');
            const headingEl = document.getElementById('riddleHeading');
            const dialogEl = document.getElementById('riddleDialog');
            const signatureEl = document.getElementById('riddleSignature');
            const disclaimerEl = document.getElementById('riddleDisclaimer');
            const inputEl = document.getElementById('riddleAnswer');
            const riddlePage = document.getElementById('riddlePage');

            if (!content || !headingEl || !dialogEl || !inputEl) {
                return;
            }

            // Clear any pending error removal timeout
            clearPendingErrorRemoval();

            hideCompletionView();

            // Set riddle ID on container for CSS targeting
            const container = content.closest('.riddle-container');
            if (container && riddle.id) {
                container.setAttribute('data-riddle-id', riddle.id);
            }

            const updateContent = () => {
                const headingText = applyPlayerName(riddle.heading, playerName);
                headingEl.innerHTML = formatHeadingWithLineBreaks(headingText);

                dialogEl.innerHTML = '';
                const whiteSegments = Array.isArray(riddle.white) ? riddle.white : (riddle.white ? [riddle.white] : []);
                whiteSegments.forEach(segment => {
                    const resolved = applyPlayerName(segment, playerName);
                    if (!resolved) {
                        return;
                    }
                    const paragraph = document.createElement('p');
                    paragraph.textContent = resolved;
                    dialogEl.appendChild(paragraph);
                });
                dialogEl.appendChild(createQuestionElement(riddle, playerName));

                if (disclaimerEl) {
                    // Special handling for riddle 8 - show interactive map
                    if (riddle.id === 8) {
                        disclaimerEl.style.display = 'block';
                        disclaimerEl.innerHTML = `
                            <div class="interactive-map-container">
                                <img src="art/map1.png" alt="Map" class="riddle-map">
                                <div class="map-clickable-area" id="steelbloom-clickable" style=" top: 30%; left: 30%; width: 12%; height: 12%;"></div>
                                <img src="art/steelbloom-glow.png" alt="Steelbloom" class="steelbloom-glow" id="steelbloom-glow">
                            </div>
                        `;
                    } else if (riddle.id === 21) {
                        // Special handling for riddle 21 - show flute game
                        disclaimerEl.style.display = 'block';
                        disclaimerEl.innerHTML = `
                            <div class="flute-game-container" id="flute-game-container">
                                <img src="art/flutel-lines.png" alt="Flute Lines" class="flute-lines" id="flute-lines">
                                <div class="flute-shadow" id="flute-shadow"></div>
                                <img src="art/flute.png" alt="Flute" class="flute-moving" id="flute-moving">
                                <div id="flute-buttons-container"></div>
                            </div>
                        `;
                    } else if (riddle.id === 17) {
                        // Special handling for riddle 17 - show Pyrai symbol game
                        disclaimerEl.style.display = 'block';
                        disclaimerEl.innerHTML = `
                            <div class="pyrai-symbol-game-container" id="pyrai-symbol-game-container">
                                <div class="pyrai-symbol-grid">
                                    <button class="pyrai-symbol-button" data-symbol="pyrai">
                                        <img src="art/pyrai-icon-inactive.png" alt="Pyrai" class="inactive-img">
                                        <img src="art/pyrai-icon-active.png" alt="Pyrai" class="active-img">
                                    </button>
                                    <button class="pyrai-symbol-button" data-symbol="dunir">
                                        <img src="art/dunir-icon-inactive.png" alt="Dunir" class="inactive-img">
                                        <img src="art/dunir-icon-wrong-selection.png" alt="Dunir" class="wrong-img">
                                    </button>
                                    <button class="pyrai-symbol-button" data-symbol="empyrean">
                                        <img src="art/empyrean-icon-inactive.png" alt="Empyrean" class="inactive-img">
                                        <img src="art/empyrean-icon-wrong-selection.png" alt="Empyrean" class="wrong-img">
                                    </button>
                                    <button class="pyrai-symbol-button" data-symbol="kaelar">
                                        <img src="art/kaelar-icon-inactive.png" alt="Kaelar" class="inactive-img">
                                        <img src="art/kaelar-icon-wrong-selection.png" alt="Kaelar" class="wrong-img">
                                    </button>
                                    <button class="pyrai-symbol-button" data-symbol="nikua">
                                        <img src="art/nikua-icon-inactive.png" alt="Nikua" class="inactive-img">
                                        <img src="art/nikua-icon-wrong-selection.png" alt="Nikua" class="wrong-img">
                                    </button>
                                    <button class="pyrai-symbol-button" data-symbol="renkai">
                                        <img src="art/renkai-icon-inactive.png" alt="Renkai" class="inactive-img">
                                        <img src="art/renkai-icon-wrong-selection.png" alt="Renkai" class="wrong-img">
                                    </button>
                                    <button class="pyrai-symbol-button" data-symbol="vaelune">
                                        <img src="art/vaelune-icon-inactive.png" alt="Vaelune" class="inactive-img">
                                        <img src="art/vaelune-icon-wrong-selection.png" alt="Vaelune" class="wrong-img">
                                    </button>
                                    <button class="pyrai-symbol-button" data-symbol="vek">
                                        <img src="art/vek-icon-inactive.png" alt="Vek" class="inactive-img">
                                        <img src="art/vek-icon-wrong-selection.png" alt="Vek" class="wrong-img">
                                    </button>
                                </div>
                            </div>
                        `;
                    } else if (riddle.id === 22) {
                        // Special handling for riddle 22 - show class rune game
                        disclaimerEl.style.display = 'block';
                        disclaimerEl.innerHTML = `
                            <div class="class-rune-game-container" id="class-rune-game-container">
                                <div class="class-rune-grid">
                                    <button class="class-rune-button" data-class="cleric">
                                        <img src="art/cleric-inactive rune.png" alt="Cleric" class="inactive-img">
                                        <img src="art/cleric-active rune.png" alt="Cleric" class="active-img">
                                        <img src="art/cleric-active rune-wrong.png" alt="Cleric" class="wrong-img">
                                    </button>
                                    <button class="class-rune-button" data-class="ranger">
                                        <img src="art/ranger-inactive rune.png" alt="Ranger" class="inactive-img">
                                        <img src="art/ranger-active rune.png" alt="Ranger" class="active-img">
                                        <img src="art/ranger-active rune-wrong.png" alt="Ranger" class="wrong-img">
                                    </button>
                                    <button class="class-rune-button" data-class="tank">
                                        <img src="art/tank-inactive rune.png" alt="Tank" class="inactive-img">
                                        <img src="art/tank-active rune.png" alt="Tank" class="active-img">
                                        <img src="art/tank-active rune-wrong.png" alt="Tank" class="wrong-img">
                                    </button>
                                    <button class="class-rune-button" data-class="fighter">
                                        <img src="art/fighter-inactive rune.png" alt="Fighter" class="inactive-img">
                                        <img src="art/fighter-active rune.png" alt="Fighter" class="active-img">
                                        <img src="art/fighter-active rune-wrong.png" alt="Fighter" class="wrong-img">
                                    </button>
                                    <button class="class-rune-button" data-class="rogue">
                                        <img src="art/rogue-inactive rune.png" alt="Rogue" class="inactive-img">
                                        <img src="art/rogue-active rune.png" alt="Rogue" class="active-img">
                                        <img src="art/rogue-active rune-wrong.png" alt="Rogue" class="wrong-img">
                                    </button>
                                    <button class="class-rune-button" data-class="mage">
                                        <img src="art/mage-inactive rune.png" alt="Mage" class="inactive-img">
                                        <img src="art/mage-active rune.png" alt="Mage" class="active-img">
                                        <img src="art/mage-active rune-wrong.png" alt="Mage" class="wrong-img">
                                    </button>
                                    <button class="class-rune-button" data-class="bard">
                                        <img src="art/bard-inactive rune.png" alt="Bard" class="inactive-img">
                                        <img src="art/bard-active rune.png" alt="Bard" class="active-img">
                                        <img src="art/bard-active rune-wrong.png" alt="Bard" class="wrong-img">
                                    </button>
                                    <button class="class-rune-button" data-class="summoner">
                                        <img src="art/summoner-inactive rune.png" alt="Summoner" class="inactive-img">
                                        <img src="art/summoner-active rune.png" alt="Summoner" class="active-img">
                                        <img src="art/summoner-active rune-wrong.png" alt="Summoner" class="wrong-img">
                                    </button>
                                </div>
                            </div>
                        `;
                    } else if (riddle.disclaimer) {
                        disclaimerEl.style.display = 'block';
                        disclaimerEl.textContent = applyPlayerName(riddle.disclaimer, playerName);
                    } else {
                        disclaimerEl.style.display = 'none';
                        disclaimerEl.innerHTML = '';
                    }
                }

                if (signatureEl) {
                    let displaySignature = riddle.signature;
                    
                    // Handle <default> signature - use selected profile or figure variant
                    if (displaySignature === '<default>') {
                        const selectedProfileId = localStorage.getItem(SELECTED_PROFILE_KEY);
                        const profiles = loadProfiles();
                        
                        let selectedProfile;
                        if (selectedProfileId) {
                            // Use selected profile from password entry
                            selectedProfile = profiles.find(p => p.id === selectedProfileId);
                        } else {
                            // Fallback to variant mapping
                            const currentVariant = localStorage.getItem(FIGURE_VARIANT_KEY) || 'hooded';
                            const variantToProfile = {
                                'hooded': profiles.find(p => p.id === 'mysterious-figure'),
                                'xenith': profiles.find(p => p.id === 'xenith'),
                                'angelcry': profiles.find(p => p.id === 'angelcry')
                            };
                            selectedProfile = variantToProfile[currentVariant];
                        }
                        
                        if (selectedProfile) {
                            displaySignature = selectedProfile.signature;
                        }
                    }
                    
                    if (displaySignature) {
                        signatureEl.style.display = 'block';
                        signatureEl.innerHTML = '';
                        applyMixedFont(applyPlayerName(displaySignature, playerName), signatureEl);
                    } else {
                        signatureEl.style.display = 'none';
                        signatureEl.innerHTML = '';
                    }
                }

                inputEl.classList.remove('success', 'error');

                if (options.inputValue !== undefined) {
                    inputEl.value = options.inputValue;
                } else {
                    inputEl.value = '';
                }

                const placeholderText = options.inputPlaceholder !== undefined
                    ? options.inputPlaceholder
                    : (riddle.placeholder || 'Enter Text Here');
                inputEl.placeholder = placeholderText;

                const shouldDisable = Boolean(options.disableInput);
                inputEl.disabled = shouldDisable;
            if (!shouldDisable) {
                inputEl.focus({ preventScroll: true });
            }

            requestAnimationFrame(() => adjustRiddleContainer());
            
            // Call onContentUpdate callback if provided (for figure variant changes during transition)
            if (options.onContentUpdate) {
                options.onContentUpdate();
            }

            // Setup interactive map for riddle 8
            if (riddle.id === 8) {
                setTimeout(() => {
                    const clickableArea = document.getElementById('steelbloom-clickable');
                    const glowImage = document.getElementById('steelbloom-glow');
                    
                    if (clickableArea && glowImage && inputEl) {
                        clickableArea.addEventListener('click', function() {
                            glowImage.classList.add('revealed');
                            const audioController = window.__audioController;
                            const steelbloomActivation = audioController?.steelbloomAudio;
                            if (steelbloomActivation) {
                                steelbloomActivation.currentTime = 0;
                                safePlay(steelbloomActivation);
                            }
                            inputEl.disabled = false;
                            inputEl.focus({ preventScroll: true });
                        });
                    }
                }, 100);
            }

            // Setup flute game for riddle 21
            if (riddle.id === 21) {
                const preloadedFluteImages = new Set();
                const preloadFluteImage = (src) => {
                    if (!src || preloadedFluteImages.has(src)) {
                        return;
                    }
                    const img = new Image();
                    img.src = src;
                    preloadedFluteImages.add(src);
                };

                const initializeFluteGame = () => {
                    const fluteContainer = document.getElementById('flute-game-container');
                    const fluteLines = document.getElementById('flute-lines');
                    const fluteMoving = document.getElementById('flute-moving');
                    const buttonsContainer = document.getElementById('flute-buttons-container');
                    
                    if (fluteContainer && fluteLines && fluteMoving && buttonsContainer && inputEl) {
                        // Define the available buttons and their keys
                        const buttonConfigs = [
                            { key: '1', offImage: 'art/flute-1-off.png', onImage: 'art/flute-1-on.png' },
                            { key: '<', offImage: 'art/flute-arrow-off.png', onImage: 'art/flute-arrow-on.png' },
                            { key: 's', offImage: 'art/flute-s-off.png', onImage: 'art/flute-s-on.png' },
                            { key: 'u', offImage: 'art/flute-u-off.png', onImage: 'art/flute-U-on.png' },
                            { key: '~', offImage: 'art/flute-~-off.png', onImage: 'art/flute-~-on.png' },
                            { key: ';', offImage: 'art/flute-;-off.png', onImage: 'art/flute-;-on.png' }
                        ];

                        buttonConfigs.forEach(config => {
                            preloadFluteImage(config.offImage);
                            preloadFluteImage(config.onImage);
                        });

                        // Wait for image to load to get proper dimensions
                        fluteLines.onload = initFluteGame;
                        if (fluteLines.complete) {
                            initFluteGame();
                        }

                        function initFluteGame() {
                            const linesHeight = fluteLines.offsetHeight;
                            const linesWidth = fluteLines.offsetWidth;
                            
                            // Define 6 line positions aligned with the actual staff lines
                            // Bottom 2 lines shifted up slightly from previous position
                            const linePositions = [
                                linesHeight * 0.12,
                                linesHeight * 0.28,
                                linesHeight * 0.40,
                                linesHeight * 0.56,
                                linesHeight * 0.72,
                                linesHeight * 0.86,
                                linesHeight * 0.96
                            ];

                            // Place one button on each line at random horizontal positions
                            const buttons = [];
                            buttonConfigs.forEach((config, index) => {
                                const button = document.createElement('img');
                                button.src = config.offImage;
                                button.className = 'flute-button';
                                button.dataset.key = config.key;
                                button.dataset.offImage = config.offImage;
                                button.dataset.onImage = config.onImage;
                                button.dataset.lineIndex = index;
                                button.dataset.activated = 'false';
                            
                            switch (config.key) {
                                case '1':
                                    button.classList.add('flute-glow-violet');
                                    break;
                                case '<':
                                    button.classList.add('flute-glow-crimson');
                                    break;
                                case 's':
                                    button.classList.add('flute-glow-neon-green');
                                    break;
                                case 'u':
                                    button.classList.add('flute-glow-neon-blue');
                                    break;
                                case '~':
                                    button.classList.add('flute-glow-neon-yellow');
                                    break;
                                case ';':
                                    button.classList.add('flute-glow-neon-orange');
                                    break;
                                default:
                                    break;
                            }
                                
                                // Random horizontal position (20% to 80% of width)
                                const randomX = 0.2 + Math.random() * 0.6;
                                const buttonX = randomX * linesWidth;
                                button.style.left = buttonX + 'px';
                                // Position on the line with subtle adjustments for select keys
                                let buttonTop = linePositions[index];
                                if (config.key === '<' || config.key === '~' || config.key === ';') {
                                    buttonTop -= linesHeight * 0.015;
                                }
                                button.style.top = buttonTop + 'px';
                                
                                buttonsContainer.appendChild(button);
                                buttons.push({
                                    element: button,
                                    config: config,
                                    lineIndex: index,
                                    position: buttonX,
                                    activated: false
                                });
                            });

                            // Flute animation state
                            let fluteX = 0;
                            let fluteDirection = 1; // 1 for right, -1 for left
                            let currentLineIndex = 0;
                            let gameCompleted = false;
                            let keydownHandler = null;

                            // Get flute width after it loads
                            const fluteWidth = fluteMoving.offsetWidth || 110;

                            // Flute stays at fixed vertical position, only moves horizontally

                            // Animate flute movement (only horizontal)
                            function animateFlute() {
                                fluteX += fluteDirection * 2.5;
                                
                                // Bounce at edges accounting for flute width
                                if (fluteX >= linesWidth - fluteWidth) {
                                    fluteX = linesWidth - fluteWidth;
                                    fluteDirection = -1;
                                } else if (fluteX <= 0) {
                                    fluteX = 0;
                                    fluteDirection = 1;
                                }
                                
                                fluteMoving.style.left = fluteX + 'px';
                                if (!gameCompleted) {
                                    requestAnimationFrame(animateFlute);
                                }
                            }

                            // Start animation
                            animateFlute();

                            // Check if flute is over a button horizontally
                            function isFluteOverButton(button) {
                                const fluteCenterX = fluteX + (fluteWidth / 2);
                                const buttonWidth = button.element.offsetWidth || 60;
                                const tolerance = Math.max(18, Math.min(40, buttonWidth * 0.35));
                                // Only check horizontal alignment since flute overlaps all lines
                                return Math.abs(fluteCenterX - button.position) <= tolerance;
                            }

                            // Handle key press
                            keydownHandler = function(e) {
                                if (gameCompleted) {
                                    return;
                                }

                                const currentButton = buttons.find(b => b.lineIndex === currentLineIndex);
                                if (!currentButton || currentButton.activated) {
                                    return;
                                }

                                const pressedKey = e.key;
                                const expectedKey = currentButton.config.key;
                                const ignoredKeys = ['Shift', 'Alt', 'Control', 'Meta', 'CapsLock', 'Tab', 'Escape', '*'];

                                // For special characters that require shift, use e.key directly
                                // For regular letters/numbers, normalize to lowercase for comparison
                                let keysMatch = false;
                                
                                if (expectedKey === '~' || expectedKey === '_' || expectedKey === '<' || 
                                    expectedKey === '>' || expectedKey === '!' || expectedKey === '@' ||
                                    expectedKey === '#' || expectedKey === '$' || expectedKey === '%' ||
                                    expectedKey === '^' || expectedKey === '&' || expectedKey === '*' ||
                                    expectedKey === '(' || expectedKey === ')' || expectedKey === '+' ||
                                    expectedKey === '{' || expectedKey === '}' || expectedKey === '|' ||
                                    expectedKey === ':' || expectedKey === '"' || expectedKey === '?') {
                                    // Special characters - exact match required
                                    keysMatch = (pressedKey === expectedKey);
                                } else if (expectedKey === 'ArrowUp' || expectedKey === 'ArrowDown' || 
                                           expectedKey === 'ArrowLeft' || expectedKey === 'ArrowRight') {
                                    // Arrow keys - exact match
                                    keysMatch = (pressedKey === expectedKey);
                                } else {
                                    // Regular keys - case insensitive
                                    keysMatch = (pressedKey.toLowerCase() === expectedKey.toLowerCase());
                                }

                                if (keysMatch) {
                                    e.preventDefault();
                                    e.stopPropagation();
                                    if (isFluteOverButton(currentButton)) {
                                        // Correct button pressed at correct position!
                                        currentButton.activated = true;
                                        currentButton.element.src = currentButton.config.onImage;
                                        currentButton.element.classList.add('activated');
                                        const audioController = window.__audioController;
                                        const fluteActivation = audioController?.fluteButtonAudio;
                                        if (fluteActivation) {
                                            fluteActivation.currentTime = 0;
                                            safePlay(fluteActivation);
                                        }
                                        
                                        // Move to next line
                                        currentLineIndex++;
                                        
                                        if (currentLineIndex >= buttons.length) {
                                            // All buttons completed!
                                            gameCompleted = true;
                                            inputEl.disabled = false;
                                            inputEl.value = '';
                                            inputEl.focus({ preventScroll: true });
                                        }
                                        // Flute stays at fixed position, no vertical movement needed
                                    } else {
                                        // Correct key, wrong timing - restart game
                                        restartGame();
                                    }
                                    return;
                                }

                                if (!ignoredKeys.includes(pressedKey)) {
                                    e.preventDefault();
                                    e.stopPropagation();
                                    restartGame();
                                }
                            };

                            // Restart game on wrong input
                            function restartGame() {
                                currentLineIndex = 0;
                                fluteX = 0;
                                fluteDirection = 1;
                                
                                buttons.forEach(button => {
                                    button.activated = false;
                                    button.element.src = button.config.offImage;
                                    button.element.classList.remove('activated');
                                });
                                
                                // Flute stays at fixed position, no vertical reset needed
                            }

                            // Add keyboard listener
                            document.addEventListener('keydown', keydownHandler);

                            // Cleanup function for when riddle changes
                            window.cleanupFluteGame = function() {
                                if (keydownHandler) {
                                    document.removeEventListener('keydown', keydownHandler);
                                }
                            };
                        }
                    }
                };

                requestAnimationFrame(() => initializeFluteGame());
            } else {
                // Cleanup previous flute game if exists
                if (window.cleanupFluteGame) {
                    window.cleanupFluteGame();
                    window.cleanupFluteGame = null;
                }
            }

            // Setup Pyrai symbol game for riddle 17
            if (riddle.id === 17) {
                setTimeout(() => {
                    const gameContainer = document.getElementById('pyrai-symbol-game-container');
                    const symbolButtons = gameContainer?.querySelectorAll('.pyrai-symbol-button');
                    const inputEl = document.getElementById('riddleAnswer');

                    if (gameContainer && symbolButtons && inputEl) {
                        const buttons = Array.from(symbolButtons);
                        const correctSymbol = 'pyrai';
                        let isPyraiActivated = false;

                        // Randomize the visual order of symbols in the grid
                        const grid = gameContainer.querySelector('.pyrai-symbol-grid');
                        const shuffledButtons = [...buttons].sort(() => Math.random() - 0.5);
                        shuffledButtons.forEach(button => grid.appendChild(button));

                        const resetGame = () => {
                            isPyraiActivated = false;
                            buttons.forEach(button => {
                                button.classList.remove('selected', 'wrong', 'completed');
                                button.removeAttribute('aria-pressed');
                                const activeImg = button.querySelector('.active-img');
                                const inactiveImg = button.querySelector('.inactive-img');
                                const wrongImg = button.querySelector('.wrong-img');
                                if (activeImg) activeImg.style.display = 'none';
                                if (inactiveImg) inactiveImg.style.display = 'block';
                                if (wrongImg) wrongImg.style.display = 'none';
                            });
                            inputEl.disabled = true;
                            inputEl.value = '';
                        };

                        const showWrongEffect = (button) => {
                            if (isPyraiActivated) return;
                            button.classList.remove('selected');
                            button.classList.add('wrong');

                            const wrongImg = button.querySelector('.wrong-img');
                            const inactiveImg = button.querySelector('.inactive-img');
                            if (wrongImg) wrongImg.style.display = 'block';
                            if (inactiveImg) inactiveImg.style.display = 'none';

                            setTimeout(() => {
                                if (!isPyraiActivated) {
                                    button.classList.remove('wrong');
                                    if (wrongImg) wrongImg.style.display = 'none';
                                    if (inactiveImg) inactiveImg.style.display = 'block';
                                }
                            }, 500);
                        };

                        const activatePyrai = () => {
                            isPyraiActivated = true;
                            inputEl.disabled = false;
                            inputEl.focus({ preventScroll: true });

                            buttons.forEach(button => {
                                const isCorrect = button.dataset.symbol === correctSymbol;
                                const activeImg = button.querySelector('.active-img');
                                const inactiveImg = button.querySelector('.inactive-img');
                                const wrongImg = button.querySelector('.wrong-img');

                                button.classList.add('completed');
                                button.setAttribute('aria-pressed', isCorrect ? 'true' : 'false');

                                if (isCorrect) {
                                    button.classList.add('selected');
                                    button.classList.remove('wrong');
                                    if (activeImg) activeImg.style.display = 'block';
                                    if (inactiveImg) inactiveImg.style.display = 'none';
                                    if (wrongImg) wrongImg.style.display = 'none';
                                } else {
                                    button.classList.remove('selected');
                                    button.classList.add('wrong');
                                    if (activeImg) activeImg.style.display = 'none';
                                    if (inactiveImg) inactiveImg.style.display = 'none';
                                    if (wrongImg) wrongImg.style.display = 'block';
                                }
                            });

                            const audioController = window.__audioController;
                            const activationSound = audioController?.classRuneAudio;
                            if (activationSound) {
                                activationSound.currentTime = 0;
                                safePlay(activationSound);
                            }
                        };

                        buttons.forEach(button => {
                            button.addEventListener('click', () => {
                                if (isPyraiActivated || button.classList.contains('completed')) return;

                                const symbolName = button.dataset.symbol;
                                if (symbolName === correctSymbol) {
                                    activatePyrai();
                                } else {
                                    showWrongEffect(button);
                                }
                            });
                        });

                        resetGame();
                    }
                }, 100);
            }

            // Setup class rune game for riddle 22
            if (riddle.id === 22) {
                setTimeout(() => {
                    const gameContainer = document.getElementById('class-rune-game-container');
                    const runeButtons = gameContainer?.querySelectorAll('.class-rune-button');
                    
                    if (gameContainer && runeButtons) {
                        // Correct sequence: Cleric, Ranger, Tank, Fighter, Rogue, Mage, Bard, Summoner
                        const correctSequence = ['cleric', 'ranger', 'tank', 'fighter', 'rogue', 'mage', 'bard', 'summoner'];
                        let currentSequence = [];
                        let isGameCompleted = false;
                        
                        // Randomize the visual order of runes in the grid
                        const runeArray = Array.from(runeButtons);
                        const shuffledRunes = [...runeArray].sort(() => Math.random() - 0.5);
                        
                        // Reorder the DOM elements
                        const grid = gameContainer.querySelector('.class-rune-grid');
                        shuffledRunes.forEach(rune => grid.appendChild(rune));
                        
                        const resetGame = () => {
                            currentSequence = [];
                            isGameCompleted = false;
                            runeButtons.forEach(button => {
                                button.classList.remove('selected', 'wrong');
                            });
                        };
                        
                        const showWrongEffect = (button) => {
                            button.classList.add('wrong');
                            setTimeout(() => {
                                button.classList.remove('wrong');
                            }, 500);
                        };
                        
                        const advanceToNextRiddle = () => {
                            setTimeout(() => {
                                advanceRiddle();
                            }, 3000);
                        };
                        
                        const checkSequence = () => {
                            if (currentSequence.length === correctSequence.length) {
                                // Check if sequence is correct
                                const isCorrect = currentSequence.every((className, index) => 
                                    className === correctSequence[index]
                                );
                                
                                if (isCorrect) {
                                    isGameCompleted = true;
                                    advanceToNextRiddle();
                                } else {
                                    // Wrong sequence, reset
                                    setTimeout(resetGame, 500);
                                }
                            }
                        };
                        
                        runeButtons.forEach(button => {
                            button.addEventListener('click', () => {
                                if (isGameCompleted) return;
                                
                                const className = button.dataset.class;
                                
                                // Check if this is the next correct class
                                const expectedClass = correctSequence[currentSequence.length];
                                
                                if (className === expectedClass) {
                                    // Correct selection
                                    currentSequence.push(className);
                                    button.classList.add('selected');
                                    
                                    // Play activation sound
                                    const audioController = window.__audioController;
                                    const activationSound = audioController?.classRuneAudio;
                                    if (activationSound) {
                                        activationSound.currentTime = 0;
                                        safePlay(activationSound);
                                    }
                                    
                                    checkSequence();
                                } else {
                                    // Wrong selection, show effect and reset
                                    showWrongEffect(button);
                                    setTimeout(resetGame, 500);
                                }
                            });
                        });
                        
                        // Initialize game state
                        resetGame();
                    }
                }, 100);
            }
            };

            if (options.useTransition) {
                content.classList.add('is-transitioning');
                const container = content.closest('.riddle-container');
                if (container) {
                    container.classList.add('is-transitioning');
                }

                setTimeout(() => {
                    updateContent();

                    // Wait for next frame to ensure content is updated, then start fade-in
                    requestAnimationFrame(() => {
                        requestAnimationFrame(() => {
                            content.classList.remove('is-transitioning');
                            if (container) {
                                container.classList.remove('is-transitioning');
                            }
                        });
                    });
                }, RIDDLE_TRANSITION_DELAY_MS);
            } else {
                updateContent();
                content.classList.remove('is-transitioning');
                const container = content.closest('.riddle-container');
                if (container) {
                    container.classList.remove('is-transitioning');
                }
            }
        }

        function renderIntroOnly(playerName) {
            const intro = RIDDLE_DEFINITION_MAP[INTRO_RIDDLE_ID];
            if (!intro) {
                return;
            }
            isShowingRiddleCompletion = false; // Not showing completion
            renderRiddleView(intro, playerName, { useTransition: false });
            // Always show hooded figure for intro riddle, ignoring custom profile
            applyFigureVariant('hooded', true);
            
            // Update dev console highlighting if visible
            refreshDevConsoleIfVisible();
        }

        function renderCurrentChallengeRiddle(useTransition) {
            if (!activeRiddleChallenge || !activeRiddleChallenge.riddles.length) {
                return;
            }
            isShowingRiddleCompletion = false; // Not showing completion
            const current = activeRiddleChallenge.riddles[activeRiddleChallenge.index];
            
            // Riddle 8 requires user to click the map before enabling input
            // Riddle 21 requires user to complete the flute game before enabling input
            const options = {
                useTransition: Boolean(useTransition),
                onContentUpdate: () => flushQueuedFigureVariant()
            };
            
            if (current.id === 8 || current.id === 17 || current.id === 21 || current.id === 22) {
                options.disableInput = true;
            }
            
            renderRiddleView(current, activeRiddleChallenge.playerName, options);
            
            // Update dev console highlighting if visible
            refreshDevConsoleIfVisible();
        }

        function renderChallengeCompletion(playerName) {
            clearPendingRiddleAdvance();
            isShowingRiddleCompletion = true; // Mark that we're showing completion
            
            // Determine which variant/guide to use for the completion message
            let variantToUse = 'hooded'; // default
            let signatureToUse = '- Mysterious Figure';
            
            if (activeRiddleChallenge) {
                // Use the variant from the active challenge
                variantToUse = activeRiddleChallenge.variant || 'hooded';
                
                // Get the signature from the profile if available
                if (activeRiddleChallenge.profileId) {
                    const profiles = loadProfiles();
                    const profile = profiles.find(p => p.id === activeRiddleChallenge.profileId);
                    if (profile && profile.signature) {
                        signatureToUse = profile.signature;
                    }
                }
            }
            
            applyFigureVariant(variantToUse, true);

            showCompletionView(playerName, signatureToUse);
            updateCompletionSelectionUI(activeRiddleChallenge?.selectedReward || null, { skipPersist: true });

            // Update dev console highlighting if visible
            refreshDevConsoleIfVisible();
        }
        
        function maybeStartRiddleChallenge(playerName, answer) {
            const normalizedAnswer = normalizeAnswer(answer);
            const profiles = loadProfiles();
            
            // Find the profile that matches this password
            const matchingProfile = profiles.find(p => 
                p.enabledAsPassword && 
                p.password && 
                normalizeAnswer(p.password) === normalizedAnswer
            );
            
            if (!matchingProfile) {
                activeRiddleChallenge = null;
                return false;
            }
            
            // Store the selected profile ID for bust/signature use
            localStorage.setItem(SELECTED_PROFILE_KEY, matchingProfile.id);
            
            // Determine figure variant based on profile
            let variant = 'hooded'; // default
            if (matchingProfile.id === 'xenith') {
                variant = 'xenith';
            } else if (matchingProfile.id === 'angelcry') {
                variant = 'angelcry';
            } else if (matchingProfile.id === 'mysterious-figure') {
                variant = 'hooded';
            } else {
                // For custom profiles, use hooded as base variant but profile will override
                variant = 'hooded';
            }
            
            setQueuedFigureVariant(variant);
            if (
                !activeRiddleChallenge ||
                normalizeAnswer(activeRiddleChallenge.playerName) !== normalizeAnswer(playerName)
            ) {
                clearPendingRiddleAdvance();
                activeRiddleChallenge = buildRiddleChallenge(playerName, variant);
            } else {
                activeRiddleChallenge.playerName = playerName;
            }
            activeRiddleChallenge.variant = variant;
            activeRiddleChallenge.profileId = matchingProfile.id;
            return true;
        }

        function prepareRiddleView() {
            const contentExists = document.getElementById('riddleContent');
            if (!contentExists) {
                return;
            }
            hideCompletionView();
            updateCompletionSelectionUI(null, { skipPersist: true });
            clearPendingRiddleAdvance();
            const playerName = getActivePlayerName();
            const restored = restoreActiveChallenge();

            if (restored) {
                activeRiddleChallenge = restored;
                localStorage.setItem(FIGURE_VARIANT_KEY, restored.variant || 'hooded');
                if (restored.completed) {
                    renderChallengeCompletion(restored.playerName);
                } else if (restored.index === 0 && restored.riddles[0]?.id === INTRO_RIDDLE_ID) {
                    setQueuedFigureVariant('hooded');
                    renderIntroOnly(restored.playerName);
                } else {
                    renderCurrentChallengeRiddle(false);
                }
            } else {
                activeRiddleChallenge = null;
                renderIntroOnly(playerName);
            }
        }

        function advanceRiddle() {
            if (!activeRiddleChallenge) {
                return;
            }
            if (activeRiddleChallenge.index >= activeRiddleChallenge.riddles.length - 1) {
                finalizeRiddleChallenge();
                return;
            }
            activeRiddleChallenge.index += 1;
            setQueuedFigureVariant(activeRiddleChallenge.variant);
            renderCurrentChallengeRiddle(true);
            saveActiveChallenge();
        }

        function finalizeRiddleChallenge() {
            if (!activeRiddleChallenge || activeRiddleChallenge.completed) {
                return;
            }
            activeRiddleChallenge.completed = true;
            saveActiveChallenge(); // Save the completed state with variant and profileId
            renderChallengeCompletion(activeRiddleChallenge.playerName);
        }

        function handleRiddleSubmission(answer) {
            const inputEl = document.getElementById('riddleAnswer');
            if (!inputEl) {
                return;
            }
            const trimmedAnswer = (answer || '').trim();
            if (!trimmedAnswer) {
                updateDevConsoleRiddleFeedback(false, 'Answer is required.');
                return;
            }

            clearPendingRiddleAdvance();
            clearPendingErrorRemoval();
            inputEl.classList.remove('error', 'success');

            const playerName = getActivePlayerName();

            if (activeRiddleChallenge && !activeRiddleChallenge.completed) {
                const current = activeRiddleChallenge.riddles[activeRiddleChallenge.index];
                const correct = isAnswerCorrect(current, trimmedAnswer, playerName);
                if (correct) {
                    inputEl.classList.add('success');
                    pendingRiddleAdvanceTimeout = setTimeout(() => {
                        advanceRiddle();
                    }, RIDDLE_ADVANCE_DELAY_MS);
                    saveActiveChallenge();
                    updateDevConsoleRiddleFeedback(true, `Correct answer for riddle ${current.id}. Advancing...`);
                } else {
                    inputEl.classList.add('error');
                    pendingErrorRemovalTimeout = setTimeout(() => {
                        inputEl.classList.remove('error');
                        pendingErrorRemovalTimeout = null;
                    }, 1200);
                    updateDevConsoleRiddleFeedback(false, 'Incorrect answer. Try again.');
                }
            } else {
                const intro = RIDDLE_DEFINITION_MAP[INTRO_RIDDLE_ID];
                const correct = isAnswerCorrect(intro, trimmedAnswer, playerName);
                if (correct) {
                    inputEl.classList.add('success');
                    if (maybeStartRiddleChallenge(playerName, trimmedAnswer)) {
                        pendingRiddleAdvanceTimeout = setTimeout(() => {
                            advanceRiddle();
                        }, RIDDLE_ADVANCE_DELAY_MS);
                        saveActiveChallenge();
                        updateDevConsoleRiddleFeedback(true, 'Intro answer accepted. Challenge started.');
                    }
                } else {
                    inputEl.classList.add('error');
                    pendingErrorRemovalTimeout = setTimeout(() => {
                        inputEl.classList.remove('error');
                        pendingErrorRemovalTimeout = null;
                    }, 1200);
                    updateDevConsoleRiddleFeedback(false, 'Incorrect intro response.');
                }
            }
        }


        function ensureOverlayState(overlay) {
            if (!overlay) {
                return;
            }

            if (overlay.dataset.transitioning === undefined) {
                overlay.dataset.transitioning = 'false';
            }
            if (overlay.dataset.queuedPage === undefined) {
                overlay.dataset.queuedPage = '';
            }
            if (overlay.dataset.transitionStart === undefined) {
                overlay.dataset.transitionStart = '';
            }
            if (overlay.dataset.completing === undefined) {
                overlay.dataset.completing = 'false';
            }
        }

        function showPage(pageId) {
            const overlay = document.getElementById('pageTransitionOverlay');
            if (!overlay) {
                performPageSwitch(pageId);
                return;
            }

            ensureOverlayState(overlay);

            if (overlay.dataset.transitioning === 'true') {
                overlay.dataset.queuedPage = pageId;
                return;
            }

            overlay.dataset.transitionStart = String(Date.now());
            overlay.dataset.completing = 'false';
            overlay.dataset.transitioning = 'true';
            overlay.classList.add('visible');

            setTimeout(() => {
                const stillTargetingRequestedPage = overlay.dataset.queuedPage === '' || overlay.dataset.queuedPage === pageId;
                if (!stillTargetingRequestedPage) {
                    overlay.dataset.transitioning = 'false';
                    overlay.dataset.completing = 'false';
                    overlay.classList.remove('visible');
                    return;
                }

                performPageSwitch(pageId, overlay);
            }, 500);
        }

        function performPageSwitch(pageId, overlay = null) {
            const targetPageId = pageId + 'Page';

            // Hide all pages
            document.querySelectorAll('.page').forEach(page => {
                const isTarget = page.id === targetPageId;
                page.classList.remove('active');

                if (!isTarget) {
                    // Force hide all non-target pages including login page when switching
                    page.style.display = 'none';

                    if (page.id === 'introPage') {
                        const introVideo = page.querySelector('#introVideo');
                        if (introVideo) {
                            introVideo.pause();
                            introVideo.currentTime = 0;
                            if (typeof deferredAudioPlayback !== 'undefined' && deferredAudioPlayback instanceof Set) {
                                deferredAudioPlayback.delete(introVideo);
                            }
                        }
                    }
                }
            });

            // Show the requested page
            const pageElement = document.getElementById(targetPageId);
            if (pageElement) {
                if (pageId === 'login' || pageId === 'signup' || pageId === 'intro') {
                    pageElement.style.display = 'flex';
                } else if (pageElement.classList.contains('signup-page')) {
                    pageElement.style.display = 'flex';
                } else {
                    pageElement.style.display = 'block';
                }

                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        pageElement.classList.add('active');
                        waitForImages(pageElement)
                            .catch(() => {})
                            .then(() => {
                                if (pageId === 'riddle') {
                                    prepareRiddleView();
                                }
                                if (pageId === 'nameEntry') {
                                    // Ensure name field is cleared for new accounts
                                    const currentUser = getCurrentUser();
                                    const playerNameInput = document.getElementById('playerName');
                                    if (playerNameInput && currentUser && !currentUser.playerName) {
                                        playerNameInput.value = '';
                                    }
                                    // Initialize the signature with mixed font
                                    const signatureEl = document.getElementById('nameEntrySignature');
                                    if (signatureEl) {
                                        signatureEl.innerHTML = '';
                                        applyMixedFont('- Mysterious Figure', signatureEl);
                                    }
                                }
                            })
                            .finally(() => {
                                finishOverlayTransition(overlay);
                            });
                        handlePageAudio(pageId);
                    });
                });

                localStorage.setItem('currentPage', pageId);
                currentPage = pageId;
                
                // Reset completion flag when leaving riddle page
                if (pageId !== 'riddle') {
                    isShowingRiddleCompletion = false;
                }

                refreshDevConsoleIfVisible();

                const navBar = document.getElementById('navBar');
                const audioToggle = document.getElementById('audioToggle');
                const shouldHideShell = (pageId === 'login' || pageId === 'intro');

                if (navBar) {
                    navBar.style.display = shouldHideShell ? 'none' : 'block';
                }

                if (audioToggle) {
                    audioToggle.style.display = shouldHideShell ? 'none' : 'flex';
                }

                if (pageId === 'intro') {
                    initializeIntroVideo();
                }

                if (shouldHideShell) {
                    const controller = window.__audioController;
                    if (controller?.backgroundMusic) {
                        controller.backgroundMusic.pause();
                        controller.backgroundMusic.currentTime = 0;
                    }
                }
            }

            adjustLightboxSize();
        }

        function finishOverlayTransition(overlay) {
            if (!overlay) {
                return;
            }

            if (overlay.dataset.transitioning !== 'true' || overlay.dataset.completing === 'true') {
                return;
            }

            overlay.dataset.completing = 'true';

            const minimumOverlayDuration = 300;
            const start = Number(overlay.dataset.transitionStart || Date.now());
            const elapsed = Date.now() - start;
            const remaining = Math.max(0, minimumOverlayDuration - elapsed);

            setTimeout(() => {
                overlay.classList.remove('visible');
                overlay.dataset.transitioning = 'false';
                overlay.dataset.transitionStart = '';
                overlay.dataset.completing = 'false';

                if (overlay.dataset.queuedPage) {
                    const queued = overlay.dataset.queuedPage;
                    overlay.dataset.queuedPage = '';
                    showPage(queued);
                }
            }, remaining + 200);
        }
        
        function adjustLightboxSize() {
            adjustRiddleContainer();
        }

        function adjustRiddleContainer() {
            const container = document.querySelector('.riddle-container');
            const content = document.querySelector('.riddle-content');
            if (!container || !content) {
                return;
            }

            container.classList.remove('small', 'medium', 'large');

            const contentHeight = content.offsetHeight;
            const contentWidth = content.offsetWidth;

            if (contentHeight < 420 && contentWidth < 500) {
                container.classList.add('small');
            } else if (contentHeight > 550 || contentWidth > 600) {
                container.classList.add('large');
            } else {
                container.classList.add('medium');
            }
        }

        function toggleLoginSignup() {
            isLoginMode = !isLoginMode;
            updateLoginSignupUI();
        }

        function updateLoginSignupUI() {
            const pageTitle = document.querySelector('#pageTitle');
            const pageLink = document.querySelector('#pageLink');
            const submitBtn = document.getElementById('submitBtn');
            const confirmEmailGroup = document.getElementById('confirmEmailGroup');
            const confirmPasswordGroup = document.getElementById('confirmPasswordGroup');

            if (!pageTitle || !pageLink || !submitBtn || !confirmEmailGroup || !confirmPasswordGroup) {
                console.warn('Login/Signup UI elements missing; skipping update.');
                return;
            }
            
            if (isLoginMode) {
                pageTitle.textContent = 'Log In';
                
                // Check if this is a returning user
                const currentUser = getCurrentUser();
                if (currentUser) {
                    pageLink.innerHTML = 'Welcome back! <a href="#" onclick="toggleLoginSignup()">Create new account</a>';
                    pageLink.style.color = '#ffffff';
                    pageLink.style.fontWeight = '500';
                } else {
                    pageLink.innerHTML = 'Don\'t have an account? <a href="#" onclick="toggleLoginSignup()">Sign Up</a>';
                    pageLink.style.color = '#ffffff';
                    pageLink.style.fontWeight = 'normal';
                }
                
                submitBtn.textContent = 'Log In';
                submitBtn.classList.add('login-mode');
                confirmEmailGroup.style.display = 'none';
                confirmPasswordGroup.style.display = 'none';
            } else {
                pageTitle.textContent = 'Sign Up';
                pageLink.innerHTML = 'Already have an account? <a href="#" onclick="toggleLoginSignup()">Log In</a>';
                pageLink.style.color = '#ffffff';
                pageLink.style.fontWeight = 'normal';
                submitBtn.textContent = 'Sign Up';
                submitBtn.classList.remove('login-mode');
                confirmEmailGroup.style.display = 'block';
                confirmPasswordGroup.style.display = 'block';
            }
        }

        // Account management functions
        function createAccount(email, password, provider = null) {
            const accounts = JSON.parse(localStorage.getItem('accounts') || '{}');
            accounts[email] = {
                password: password,
                playerName: null,
                riddleAnswer: null,
                introSeen: false, // Track if user has seen intro video
                provider: provider, // Track the login provider
                createdAt: new Date().toISOString()
            };
            localStorage.setItem('accounts', JSON.stringify(accounts));
            // Set current user FIRST, then clear challenge state for the new user
            localStorage.setItem('currentUser', email);
            clearActiveChallengeState();
        }

        function loginAccount(email, password) {
            const accounts = JSON.parse(localStorage.getItem('accounts') || '{}');
            if (accounts[email] && accounts[email].password === password) {
                // Migrate old accounts to have introSeen field
                if (accounts[email].introSeen === undefined) {
                    accounts[email].introSeen = localStorage.getItem(INTRO_SEEN_KEY) === 'true';
                    localStorage.setItem('accounts', JSON.stringify(accounts));
                }
                
                // Set current user FIRST, then clear challenge state for the new user
                localStorage.setItem('currentUser', email);
                clearActiveChallengeState();
                return accounts[email];
            }
            return null;
        }

        function getCurrentUser() {
            const email = localStorage.getItem('currentUser');
            if (email) {
                const accounts = JSON.parse(localStorage.getItem('accounts') || '{}');
                return accounts[email] || null;
            }
            return null;
        }

         function routeUser(user) {
             if (!user) {
                showPage('login');
                 return;
            }

            if (!hasSeenIntro()) {
                showPage('intro');
                return;
            }
             
             if (!user.playerName) {
                 showPage('nameEntry');
             } else if (!user.riddleAnswer) {
                 showPage('riddle');
             } else {
                 // User has completed everything, stay on riddle page
                 showPage('riddle');
             }
         }

        function handleSubmit() {
            const email = document.getElementById('email').value;
            const password = document.getElementById('password').value;
            
            if (!email || !password) {
                alert('Please fill in all fields');
                return;
            }
            
            if (isLoginMode) {
                // Login logic
                const user = loginAccount(email, password);
                if (user) {
                    alert('Login successful!');
                    // Small delay to ensure DOM is ready
                    setTimeout(() => {
                        routeUser(user);
                    }, 100);
                } else {
                    alert('Invalid email or password');
                }
            } else {
                // Signup logic
                const confirmEmail = document.getElementById('confirmEmail').value;
                const confirmPassword = document.getElementById('confirmPassword').value;
                
                if (!confirmEmail || !confirmPassword) {
                    alert('Please fill in all fields');
                    return;
                }
                
                if (email !== confirmEmail) {
                    alert('Emails do not match');
                    return;
                }
                
                if (password !== confirmPassword) {
                    alert('Passwords do not match');
                    return;
                }
                
                // Check if account already exists
                const accounts = JSON.parse(localStorage.getItem('accounts') || '{}');
                if (accounts[email]) {
                    alert('Account already exists. Please log in instead.');
                    isLoginMode = true;
                    updateLoginSignupUI();
                    return;
                }
                
                 // Create new account
                 createAccount(email, password);
                 alert('Account created successfully!');
                 
                 // Small delay to ensure DOM is ready
                 setTimeout(() => {
                     // Get the newly created user and route them
                     const newUser = getCurrentUser();
                     routeUser(newUser);
                 }, 100);
            }
        }

         function handleSocialLogin(provider) {
             // Check if user already has a Discord account
             const accounts = JSON.parse(localStorage.getItem('accounts') || '{}');
             let existingDiscordAccount = null;
             let existingDiscordEmail = null;
             
             // Look for existing Discord account by checking provider field first, then email pattern as fallback
             for (const email in accounts) {
                 if (accounts[email].provider === provider) {
                     existingDiscordAccount = accounts[email];
                     existingDiscordEmail = email;
                     break;
                 }
             }
             
             // Fallback: check email pattern for older accounts without provider field
             if (!existingDiscordAccount) {
                 for (const email in accounts) {
                     if (email.includes('@' + provider + '.com')) {
                         existingDiscordAccount = accounts[email];
                         existingDiscordEmail = email;
                         break;
                     }
                 }
             }
             
            if (existingDiscordAccount) {
                // User already has a Discord account, log them in
                // Migrate old accounts to have introSeen field
                if (existingDiscordAccount.introSeen === undefined) {
                    existingDiscordAccount.introSeen = localStorage.getItem(INTRO_SEEN_KEY) === 'true';
                    accounts[existingDiscordEmail] = existingDiscordAccount;
                    localStorage.setItem('accounts', JSON.stringify(accounts));
                }
                
                // Set current user FIRST, then clear challenge state for the new user
                localStorage.setItem('currentUser', existingDiscordEmail);
                clearActiveChallengeState();
                alert('Welcome back! Logged in with ' + provider.charAt(0).toUpperCase() + provider.slice(1) + ' successfully!');
                
                // Small delay to ensure DOM is ready
                setTimeout(() => {
                    routeUser(existingDiscordAccount);
                }, 100);
            } else {
                // Create new Discord account
                const fakeEmail = 'user' + Date.now() + '@' + provider + '.com';
                const fakePassword = provider + '123';
                createAccount(fakeEmail, fakePassword, provider);
                alert('Logged in with ' + provider.charAt(0).toUpperCase() + provider.slice(1) + ' successfully!');
                 
                 // Small delay to ensure DOM is ready
                 setTimeout(() => {
                     // Get the newly created user and route them
                     const newUser = getCurrentUser();
                     routeUser(newUser);
                 }, 100);
             }
         }


        function proceedToRiddle() {
            const playerName = document.getElementById('playerName').value.trim();
            if (!playerName) {
                alert('Please enter your name');
                return;
            }
            
            // Update user account with player name
            const currentUser = getCurrentUser();
            if (currentUser) {
                const email = localStorage.getItem('currentUser');
                const accounts = JSON.parse(localStorage.getItem('accounts') || '{}');
                accounts[email].playerName = playerName;
                localStorage.setItem('accounts', JSON.stringify(accounts));
            }
            
            showPage('riddle');
        }

        function submitRiddleAnswer() {
            const answer = document.getElementById('riddleAnswer')?.value?.trim();
            if (!answer) {
                alert('Please enter an answer');
                return;
            }
            handleRiddleSubmission(answer);
        }

        function waitForImages(container) {
            if (!container) {
                return Promise.resolve();
            }

            const images = Array.from(container.querySelectorAll('img'))
                .filter(img => !img.complete);

            if (!images.length) {
                return Promise.resolve();
            }

            return Promise.all(
                images.map(img => new Promise(resolve => {
                    const cleanUp = () => {
                        img.removeEventListener('load', cleanUp);
                        img.removeEventListener('error', cleanUp);
                        resolve();
                    };

                    img.addEventListener('load', cleanUp, { once: true });
                    img.addEventListener('error', cleanUp, { once: true });
                }))
            );
        }

        // Function to pre-fill login form with existing user data
        function prefillLoginForm() {
            const currentUser = getCurrentUser();
            if (currentUser) {
                const email = localStorage.getItem('currentUser');
                if (email) {
                    document.getElementById('email').value = email;
                    document.getElementById('password').value = currentUser.password;
                    
                    // Switch to login mode and update UI
                    isLoginMode = true;
                    updateLoginSignupUI();
                    
                    // Add a helpful message
                    const pageLink = document.getElementById('pageLink');
                    if (pageLink) {
                        pageLink.innerHTML = 'Welcome back! <a href="#" onclick="toggleLoginSignup()">Create new account</a>';
                        pageLink.style.color = '#ffffff';
                        pageLink.style.fontWeight = '500';
                    }
                }
            }
        }

        // Event listeners
    document.addEventListener('DOMContentLoaded', function() {
            // Initialize the login/signup UI first
            updateLoginSignupUI();
            
            // Ensure login page is properly centered from the start
            showPage('login');
            initializeGlobalAudio();
            setupUserInteractionGate();

            if (hasSeenIntro()) {
                markIntroSeen();
            }
            restoreFigureVariant();
            
            // Adjust lightbox size on load
            setTimeout(() => {
                adjustLightboxSize();
            }, 200);
            
            // Pre-fill login form if user exists
            setTimeout(() => {
                prefillLoginForm();
            }, 50);
            
            // Add event listeners
            const playerNameInput = document.getElementById('playerName');
            const riddleAnswerInput = document.getElementById('riddleAnswer');
            
            if (playerNameInput) {
                playerNameInput.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        proceedToRiddle();
                    }
                });
            }
            
            if (riddleAnswerInput) {
                riddleAnswerInput.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        submitRiddleAnswer();
                    }
                });
            }
            
            // Restore form data if available
            // Note: We don't restore playerName here as it should only appear when
            // the user is returning to edit it, not when creating a new account
            const currentUserForRestore = getCurrentUser();
            if (currentUserForRestore) {
                if (currentUserForRestore.riddleAnswer && riddleAnswerInput) {
                    riddleAnswerInput.value = currentUserForRestore.riddleAnswer;
                }
            }

            initializeDevConsoleElements();
            restoreCustomRiddles();
            setupCompletionRewardEvents();
        });

        const INTRO_VIDEO_PATH = 'intro/Challenge_Intro_Video.mov';
        const INTRO_SEEN_KEY = 'introSeen';

        function markIntroSeen() {
            const currentUser = getCurrentUser();
            const email = localStorage.getItem('currentUser');
            if (currentUser && email) {
                const accounts = JSON.parse(localStorage.getItem('accounts') || '{}');
                if (accounts[email]) {
                    accounts[email].introSeen = true;
                    localStorage.setItem('accounts', JSON.stringify(accounts));
                }
            }
            // Keep the old global key for backwards compatibility
            localStorage.setItem(INTRO_SEEN_KEY, 'true');
        }

        function hasSeenIntro() {
            const currentUser = getCurrentUser();
            const email = localStorage.getItem('currentUser');
            if (currentUser && email) {
                const accounts = JSON.parse(localStorage.getItem('accounts') || '{}');
                if (accounts[email] && accounts[email].introSeen !== undefined) {
                    return accounts[email].introSeen === true;
                }
            }
            // Fallback to global key for backwards compatibility with existing users
            return localStorage.getItem(INTRO_SEEN_KEY) === 'true';
        }

        function initializeIntroVideo() {
            const video = document.getElementById('introVideo');
            if (!video) {
                return;
            }

            video.src = INTRO_VIDEO_PATH;
            video.defaultPlayerStateApplied = false;
            const applyInitialVideoState = () => {
                if (video.defaultPlayerStateApplied) return;
                const shouldMute = localStorage.getItem('audioMuted') === 'true';
                video.muted = shouldMute;
                video.defaultPlayerStateApplied = true;
                const playPromise = video.play();
                if (playPromise && typeof playPromise.catch === 'function') {
                    playPromise.catch(() => {
                        deferredAudioPlayback.add(video);
                    });
                }
            };

            video.addEventListener('loadedmetadata', applyInitialVideoState, { once: true });
            applyInitialVideoState();

            video.addEventListener('ended', () => {
                markIntroSeen();
                routeUserAfterIntro();
            });
        }

        function routeUserAfterIntro() {
            const currentUser = getCurrentUser();
            if (currentUser) {
                markIntroSeen();
                routeUser(currentUser);
            } else {
                markIntroSeen();
                showPage('login');
            }
        }

let hasUserInteracted = false;
const deferredAudioPlayback = new Set();

function setupUserInteractionGate() {
    if (setupUserInteractionGate.initialized) return;

    const unlockAudio = () => {
        if (hasUserInteracted) return;
        hasUserInteracted = true;
        deferredAudioPlayback.forEach(media => {
            media.play().catch(() => {});
        });
        deferredAudioPlayback.clear();
    };

    ['click', 'keydown', 'touchstart'].forEach(eventName => {
        document.addEventListener(eventName, unlockAudio, { once: true, passive: true });
    });

    setupUserInteractionGate.initialized = true;
}

function safePlay(mediaElement) {
    if (!mediaElement) return;
    const playPromise = mediaElement.play?.();
    if (playPromise && typeof playPromise.catch === 'function') {
        playPromise.catch(() => {
            deferredAudioPlayback.add(mediaElement);
        });
    }
}

        function initializeGlobalAudio() {
            const audioToggle = document.getElementById('audioToggle');
            const volumeSlider = document.getElementById('volumeSlider');
            const audioIcon = document.getElementById('audioIcon');
            const introVideo = document.getElementById('introVideo');
            let backgroundMusic = document.getElementById('backgroundMusic');
            let stagVoice = document.getElementById('stagVoiceover');
            let fluteButtonAudio = document.getElementById('fluteButtonAudio');
            let steelbloomAudio = document.getElementById('steelbloomAudio');
            let classRuneAudio = document.getElementById('classRuneAudio');

            // Get saved volume from localStorage for initial setup
            const initialVolume = parseFloat(localStorage.getItem('audioVolume') || '15') / 100;

            if (!backgroundMusic) {
                backgroundMusic = document.createElement('audio');
                backgroundMusic.id = 'backgroundMusic';
        backgroundMusic.src = 'sound/Alex-Productions-Challenge_Theme_Song_Battle.mp3';
                backgroundMusic.loop = true;
                backgroundMusic.preload = 'auto';
                backgroundMusic.dataset.baseVolume = '0.6';
                backgroundMusic.volume = initialVolume * 0.6;
                document.body.appendChild(backgroundMusic);

        // Don't auto-play on canplay - let handlePageAudio control playback
        // This prevents music from starting on login/intro pages
            } else {
                // Ensure existing audio has baseVolume set
                if (!backgroundMusic.dataset.baseVolume) {
                    backgroundMusic.dataset.baseVolume = '0.6';
                }
                backgroundMusic.volume = initialVolume * parseFloat(backgroundMusic.dataset.baseVolume);
            }

            if (!stagVoice) {
                stagVoice = document.createElement('audio');
                stagVoice.id = 'stagVoiceover';
                stagVoice.src = 'sound/hooded-figure-stag-has-guided-you-well-voiceover.mp3';
                stagVoice.preload = 'auto';
                stagVoice.dataset.baseVolume = '1.0';
                stagVoice.volume = initialVolume * 1.0;
                stagVoice.dataset.played = localStorage.getItem('stagVoicePlayed') || 'false';
                document.body.appendChild(stagVoice);

                // Force load the audio immediately
                stagVoice.load();

                stagVoice.addEventListener('ended', () => {
                    localStorage.setItem('stagVoicePlayed', 'true');
                    stagVoice.dataset.played = 'true';
                    fadeAudio(backgroundMusic, true);
                });
                
                // Log when audio is ready to play
                stagVoice.addEventListener('canplaythrough', () => {
                    console.log('Stag voiceover ready to play');
                }, { once: true });
            } else {
                // Ensure existing audio has baseVolume set
                if (!stagVoice.dataset.baseVolume) {
                    stagVoice.dataset.baseVolume = '1.0';
                }
                stagVoice.volume = initialVolume * parseFloat(stagVoice.dataset.baseVolume);
            }

            if (!fluteButtonAudio) {
                fluteButtonAudio = document.createElement('audio');
                fluteButtonAudio.id = 'fluteButtonAudio';
                fluteButtonAudio.src = 'sound/flute-button-activation.wav';
                fluteButtonAudio.preload = 'auto';
                fluteButtonAudio.dataset.baseVolume = '0.8';
                fluteButtonAudio.volume = initialVolume * 0.8;
                document.body.appendChild(fluteButtonAudio);
            } else {
                if (!fluteButtonAudio.dataset.baseVolume) {
                    fluteButtonAudio.dataset.baseVolume = '0.8';
                }
                fluteButtonAudio.volume = initialVolume * parseFloat(fluteButtonAudio.dataset.baseVolume);
            }

            if (!steelbloomAudio) {
                steelbloomAudio = document.createElement('audio');
                steelbloomAudio.id = 'steelbloomAudio';
                steelbloomAudio.src = 'sound/map-riddle-steelbloom-activation.wav';
                steelbloomAudio.preload = 'auto';
                steelbloomAudio.dataset.baseVolume = '1.0';
                steelbloomAudio.volume = initialVolume * 1.0;
                document.body.appendChild(steelbloomAudio);
            } else {
                if (!steelbloomAudio.dataset.baseVolume) {
                    steelbloomAudio.dataset.baseVolume = '1.0';
                }
                steelbloomAudio.volume = initialVolume * parseFloat(steelbloomAudio.dataset.baseVolume);
            }

            if (!classRuneAudio) {
                classRuneAudio = document.createElement('audio');
                classRuneAudio.id = 'classRuneAudio';
                classRuneAudio.src = 'sound/class-rune-riddle-activation.wav';
                classRuneAudio.preload = 'auto';
                classRuneAudio.dataset.baseVolume = '0.8';
                classRuneAudio.volume = initialVolume * 0.8;
                document.body.appendChild(classRuneAudio);
            } else {
                if (!classRuneAudio.dataset.baseVolume) {
                    classRuneAudio.dataset.baseVolume = '0.8';
                }
                classRuneAudio.volume = initialVolume * parseFloat(classRuneAudio.dataset.baseVolume);
            }

            const updateAudioIcon = (muted) => {
                const waves = audioIcon?.querySelectorAll('.wave');
                const muteX = audioIcon?.querySelector('.mute-x');
                if (waves && muteX) {
                    waves.forEach(wave => wave.style.display = muted ? 'none' : '');
                    muteX.style.display = muted ? '' : 'none';
                }
            };

            const applyMuteState = (muted) => {
                audioToggle?.classList.toggle('is-muted', muted);
                updateAudioIcon(muted);
                if (introVideo) introVideo.muted = muted;
                if (backgroundMusic) backgroundMusic.muted = muted;
                if (stagVoice) stagVoice.muted = muted;
                if (fluteButtonAudio) fluteButtonAudio.muted = muted;
                if (steelbloomAudio) steelbloomAudio.muted = muted;
                if (classRuneAudio) classRuneAudio.muted = muted;
            };

            const applyVolumeState = (volume) => {
                const volumeValue = volume / 100;
                if (backgroundMusic) {
                    backgroundMusic.dataset.baseVolume = '0.6';
                    backgroundMusic.volume = volumeValue * 0.6;
                }
                if (introVideo) introVideo.volume = volumeValue;
                if (stagVoice) {
                    stagVoice.dataset.baseVolume = '1.0';
                    stagVoice.volume = volumeValue * 1.0;
                }
                if (fluteButtonAudio) {
                    const baseVolume = parseFloat(fluteButtonAudio.dataset.baseVolume || '0.8');
                    fluteButtonAudio.volume = volumeValue * baseVolume;
                }
                if (steelbloomAudio) {
                    const baseVolume = parseFloat(steelbloomAudio.dataset.baseVolume || '1.0');
                    steelbloomAudio.volume = volumeValue * baseVolume;
                }
                if (classRuneAudio) {
                    const baseVolume = parseFloat(classRuneAudio.dataset.baseVolume || '0.8');
                    classRuneAudio.volume = volumeValue * baseVolume;
                }
                localStorage.setItem('audioVolume', volume);
            };

            // Initialize saved states
            const savedMuted = localStorage.getItem('audioMuted') === 'true';
            const savedVolume = localStorage.getItem('audioVolume') || '15';
            applyMuteState(savedMuted);
            
            if (volumeSlider) {
                volumeSlider.value = savedVolume;
                applyVolumeState(savedVolume);
            }

            // Handle mute toggle on icon click
            audioIcon?.addEventListener('click', (e) => {
                e.stopPropagation();
                const newMuted = !(backgroundMusic?.muted ?? savedMuted);
                localStorage.setItem('audioMuted', newMuted ? 'true' : 'false');
                applyMuteState(newMuted);
                if (!newMuted) {
                    if (backgroundMusic?.paused && currentPage !== 'login' && currentPage !== 'intro') {
                        safePlay(backgroundMusic);
                    }
                }
            });

            // Handle volume slider
            volumeSlider?.addEventListener('input', (e) => {
                const volume = e.target.value;
                applyVolumeState(volume);
                
                // Auto-unmute when adjusting volume
                if (volume > 0 && (backgroundMusic?.muted ?? savedMuted)) {
                    localStorage.setItem('audioMuted', 'false');
                    applyMuteState(false);
                    if (backgroundMusic?.paused && currentPage !== 'login' && currentPage !== 'intro') {
                        safePlay(backgroundMusic);
                    }
                }
            });

            window.__audioController = {
                backgroundMusic,
                stagVoice,
                fluteButtonAudio,
                steelbloomAudio,
                classRuneAudio,
                playStagOnce: () => {
                    if (!stagVoice || !backgroundMusic) return;
                    if (stagVoice.dataset.played === 'true') return;
                    
                    // Fade out background music
                    fadeAudio(backgroundMusic, false, 600);
                    
                    // Ensure the audio is at the beginning
                    stagVoice.currentTime = 0;
                    
                    // Ensure audio is not muted and has proper volume
                    const isMuted = localStorage.getItem('audioMuted') === 'true';
                    stagVoice.muted = isMuted;
                    
                    const userVolume = parseFloat(localStorage.getItem('audioVolume') || '15') / 100;
                    const baseVolume = parseFloat(stagVoice.dataset.baseVolume || '1.0');
                    stagVoice.volume = userVolume * baseVolume;
                    
                    // Force play immediately with error handling
                    const playPromise = stagVoice.play();
                    if (playPromise !== undefined) {
                        playPromise.then(() => {
                            console.log('Stag voiceover playing successfully');
                        }).catch(error => {
                            console.warn('Stag voiceover play failed:', error);
                            // Retry once after a brief delay
                            setTimeout(() => {
                                stagVoice.play().catch(e => console.error('Stag retry failed:', e));
                            }, 100);
                        });
                    }
                }
            };

            handlePageAudio(currentPage);
        }

function fadeAudio(audioElement, fadeIn = true, duration = 800, targetVolume = null) {
            if (!audioElement) return;
            
            // Get the user's current volume setting
            const userVolume = parseFloat(localStorage.getItem('audioVolume') || '15') / 100;
            const baseVolume = parseFloat(audioElement.dataset.baseVolume || '1.0');
            const effectiveTargetVolume = targetVolume !== null ? targetVolume : (userVolume * baseVolume);
            
            const startVolume = fadeIn ? 0 : audioElement.volume;
            const endVolume = fadeIn ? effectiveTargetVolume : 0;
            const startTime = performance.now();

            const step = (now) => {
                const elapsed = now - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const currentVolume = startVolume + (endVolume - startVolume) * progress;
                audioElement.volume = Math.max(0, Math.min(effectiveTargetVolume, currentVolume));

                if (progress < 1) {
                    requestAnimationFrame(step);
                } else if (!fadeIn) {
                    audioElement.pause();
                }
            };

    if (fadeIn && audioElement.paused) {
        safePlay(audioElement);
            }

            requestAnimationFrame(step);
        }

        function handlePageAudio(pageId) {
            const controller = window.__audioController;
            if (!controller) return;

            if (pageId === 'intro' || pageId === 'login') {
                if (controller.backgroundMusic) {
                    controller.backgroundMusic.pause();
                    controller.backgroundMusic.currentTime = 0;
                }
                return;
            }

            if (pageId === 'nameEntry') {
                controller.playStagOnce();
                return;
            }

            fadeAudio(controller.backgroundMusic, true, 600);
        }

        function saveActiveChallenge() {
            if (!activeRiddleChallenge) {
                const currentUserEmail = localStorage.getItem('currentUser');
                if (currentUserEmail) {
                    localStorage.removeItem(ACTIVE_CHALLENGE_KEY + '_' + currentUserEmail);
                }
                localStorage.removeItem(ACTIVE_CHALLENGE_KEY);
                return;
            }

            const serialized = {
                playerName: activeRiddleChallenge.playerName,
                index: activeRiddleChallenge.index,
                riddles: activeRiddleChallenge.riddles.map(r => r.id || r.originalId || r),
                completed: activeRiddleChallenge.completed,
                variant: activeRiddleChallenge.variant || localStorage.getItem(FIGURE_VARIANT_KEY) || 'hooded',
                profileId: activeRiddleChallenge.profileId || localStorage.getItem(SELECTED_PROFILE_KEY),
                selectedReward: activeRiddleChallenge.selectedReward || null,
                rewardSubmitted: Boolean(activeRiddleChallenge.rewardSubmitted)
            };

            // Save challenge state specific to the current user
            const currentUserEmail = localStorage.getItem('currentUser');
            if (currentUserEmail) {
                localStorage.setItem(ACTIVE_CHALLENGE_KEY + '_' + currentUserEmail, JSON.stringify(serialized));
            } else {
                localStorage.setItem(ACTIVE_CHALLENGE_KEY, JSON.stringify(serialized));
            }
        }

        function restoreActiveChallenge() {
            try {
                // Get challenge state specific to the current user
                const currentUserEmail = localStorage.getItem('currentUser');
                let raw = null;
                if (currentUserEmail) {
                    raw = localStorage.getItem(ACTIVE_CHALLENGE_KEY + '_' + currentUserEmail);
                }
                // Fallback to non-user-specific key for backwards compatibility
                if (!raw) {
                    raw = localStorage.getItem(ACTIVE_CHALLENGE_KEY);
                }
                if (!raw) {
                    return null;
                }
                const parsed = JSON.parse(raw);
                if (!parsed || !Array.isArray(parsed.riddles)) {
                    return null;
                }

                const queuedVariant = parsed.variant && FIGURE_IMAGE_MAP[parsed.variant] ? parsed.variant : 'hooded';
                setQueuedFigureVariant(queuedVariant);
                
                // Restore selected profile ID if present
                if (parsed.profileId) {
                    localStorage.setItem(SELECTED_PROFILE_KEY, parsed.profileId);
                }

                const orderedRiddles = parsed.riddles
                    .map(id => RIDDLE_DEFINITION_MAP[id])
                    .filter(Boolean)
                    .map(riddle => ({ ...riddle }));

                if (!orderedRiddles.length) {
                    return null;
                }

                const normalizedIndex = Math.min(
                    Math.max(parsed.index || 0, 0),
                    orderedRiddles.length - 1
                );

                return {
                    playerName: parsed.playerName || getActivePlayerName(),
                    index: normalizedIndex,
                    riddles: orderedRiddles,
                    completed: Boolean(parsed.completed),
                    variant: queuedVariant,
                    profileId: parsed.profileId,
                    selectedReward: parsed.selectedReward || null,
                    rewardSubmitted: Boolean(parsed.rewardSubmitted)
                };
            } catch (error) {
                return null;
            }
        }

        function initializeDevConsoleElements() {
            const overlay = document.getElementById('devConsoleOverlay');
            if (!overlay) {
                return;
            }

            // Ensure profiles are initialized
            loadProfiles();

            DevConsoleState.elements = {
                overlay,
                close: document.getElementById('devConsoleClose'),
                closeBtn: document.getElementById('devConsoleCloseBtn'),
                toggleBtn: document.getElementById('devConsoleToggle'),
                lock: document.getElementById('devConsoleLock'),
                content: document.getElementById('devConsoleContent'),
                passwordInput: document.getElementById('devConsolePassword'),
                unlockButton: document.getElementById('devConsoleUnlock'),
                error: document.getElementById('devConsoleError'),
                menu: overlay.querySelector('.dev-console-menu'),
                panels: overlay.querySelectorAll('.dev-console-panel'),
                pageList: document.getElementById('devConsolePageList'),
                accountsTableBody: document.querySelector('#devConsoleAccountsTable tbody'),
                accountsSummary: document.getElementById('devConsoleAccountsSummary'),
                addRiddleForm: document.getElementById('devConsoleAddRiddleForm'),
                riddleName: document.getElementById('devConsoleRiddleName'),
                riddleWhite: document.getElementById('devConsoleRiddleWhite'),
                riddleQuestion: document.getElementById('devConsoleRiddleQuestion'),
                riddleAnswers: document.getElementById('devConsoleRiddleAnswers'),
                riddleSignature: document.getElementById('devConsoleRiddleSignature'),
                riddleFeedback: document.getElementById('devConsoleRiddleFeedback'),
                resetForm: document.getElementById('devConsoleResetForm'),
                riddleList: document.getElementById('devConsoleRiddleList'),
                exportRiddlesButton: document.getElementById('devConsoleExportRiddles'),
                importRiddlesButton: document.getElementById('devConsoleImportRiddles'),
                importRiddlesInput: document.getElementById('devConsoleRiddleImportInput'),
                clearAccountsButton: document.getElementById('devConsoleClearAccounts'),
                profileList: document.getElementById('devConsoleProfileList'),
                showAddProfileButton: document.getElementById('devConsoleShowAddProfile'),
                profileImageInput: document.getElementById('devConsoleProfileImageInput'),
                profileFeedback: document.getElementById('devConsoleProfileFeedback'),
                profileEditor: document.getElementById('devConsoleProfileEditor'),
                profileEditorTitle: document.getElementById('devConsoleProfileEditorTitle'),
                profileForm: document.getElementById('devConsoleProfileForm'),
                profileName: document.getElementById('devConsoleProfileName'),
                profileSignature: document.getElementById('devConsoleProfileSignature'),
                profilePassword: document.getElementById('devConsoleProfilePassword'),
                profileEnabled: document.getElementById('devConsoleProfileEnabled'),
                selectProfileImage: document.getElementById('devConsoleSelectProfileImage'),
                profileImageName: document.getElementById('devConsoleProfileImageName'),
                profileImagePreview: document.getElementById('devConsoleProfileImagePreview'),
                profileImagePreviewImg: document.getElementById('devConsoleProfileImagePreviewImg'),
                cancelProfileEdit: document.getElementById('devConsoleCancelProfileEdit'),
                resetProfileForm: document.getElementById('devConsoleResetProfileForm'),
                profileFormFeedback: document.getElementById('devConsoleProfileFormFeedback')
            };

            setupDevConsoleEvents();
            renderDevConsolePages();
            refreshDevConsolePagesActiveState();
            populateSignatureDropdown();
        }

        function setupDevConsoleEvents() {
            const {
                overlay,
                close,
                closeBtn,
                toggleBtn,
                unlockButton,
                passwordInput,
                menu,
                addRiddleForm,
                resetForm,
                exportRiddlesButton,
                importRiddlesButton,
                importRiddlesInput,
                clearAccountsButton,
                showAddProfileButton,
                profileImageInput,
                profileForm,
                selectProfileImage,
                cancelProfileEdit,
                resetProfileForm
            } = DevConsoleState.elements;

            close?.addEventListener('click', hideDevConsole);
            closeBtn?.addEventListener('click', closeDevConsole);
            toggleBtn?.addEventListener('click', toggleDevConsole);

            unlockButton?.addEventListener('click', handleDevConsoleUnlock);
            passwordInput?.addEventListener('keydown', event => {
                if (event.key === 'Enter') {
                    event.preventDefault();
                    handleDevConsoleUnlock();
                }
            });

            document.addEventListener('keydown', handleDevConsoleKeydown, true);

            menu?.querySelectorAll('button').forEach(button => {
                button.addEventListener('click', () => {
                    switchDevConsolePanel(button.dataset.panel);
                });
            });

            addRiddleForm?.addEventListener('submit', handleDevConsoleRiddleSubmit);
            resetForm?.addEventListener('click', resetDevConsoleRiddleForm);
            exportRiddlesButton?.addEventListener('click', exportRiddles);
            importRiddlesButton?.addEventListener('click', () => importRiddlesInput?.click());
            importRiddlesInput?.addEventListener('change', event => {
                const file = event.target.files?.[0];
                importRiddles(file);
                event.target.value = '';
            });
            clearAccountsButton?.addEventListener('click', handleClearAllAccounts);
            
            // Profile management events
            showAddProfileButton?.addEventListener('click', showAddProfileForm);
            profileForm?.addEventListener('submit', handleProfileFormSubmit);
            selectProfileImage?.addEventListener('click', () => profileImageInput?.click());
            profileImageInput?.addEventListener('change', handleProfileImageSelection);
            cancelProfileEdit?.addEventListener('click', hideProfileEditor);
            resetProfileForm?.addEventListener('click', resetProfileFormFields);
        }

        function handleDevConsoleKeydown(event) {
            // Check if Shift is held and the key is '*' (which is Shift+8)
            if (!event.shiftKey || event.key !== '*') {
                DevConsoleState.recentKeypressCount = 0;
                return;
            }

            const now = Date.now();
            if (now - DevConsoleState.lastKeyTime > 800) {
                DevConsoleState.recentKeypressCount = 0;
            }

            DevConsoleState.recentKeypressCount += 1;
            DevConsoleState.lastKeyTime = now;

            if (DevConsoleState.recentKeypressCount >= 5) {
                event.preventDefault();
                DevConsoleState.recentKeypressCount = 0;
                toggleDevConsole();
            }
        }

        function toggleDevConsole() {
            if (DevConsoleState.isVisible) {
                hideDevConsole();
            } else {
                showDevConsole();
            }
        }

        function showDevConsole() {
            const { overlay, passwordInput, toggleBtn } = DevConsoleState.elements;
            if (!overlay) {
                return;
            }

            overlay.classList.add('is-visible');
            overlay.setAttribute('aria-hidden', 'false');
            toggleBtn?.classList.add('panel-open');
            DevConsoleState.isVisible = true;

            if (!DevConsoleState.isUnlocked || Date.now() > DevConsoleState.unlockExpiresAt) {
                lockDevConsole();
                requestAnimationFrame(() => passwordInput?.focus());
            } else {
                unlockDevConsoleUI();
            }
        }

        function hideDevConsole() {
            const { overlay, passwordInput, toggleBtn } = DevConsoleState.elements;
            overlay?.classList.remove('is-visible');
            overlay?.setAttribute('aria-hidden', 'true');
            toggleBtn?.classList.remove('panel-open');
            DevConsoleState.isVisible = false;
            DevConsoleState.recentKeypressCount = 0;
            // Don't clear password or hide toggle button when minimizing - only when fully closing
        }

        function closeDevConsole() {
            hideDevConsole();
            lockDevConsole();
            DevConsoleState.isUnlocked = false;
            DevConsoleState.unlockExpiresAt = 0;
        }

        function lockDevConsole() {
            const { lock, content, error, passwordInput, toggleBtn } = DevConsoleState.elements;
            lock?.classList.remove('hidden');
            content?.classList.add('hidden');
            toggleBtn?.classList.remove('is-visible');
            if (error) {
                error.textContent = '';
            }
            if (passwordInput) {
                passwordInput.value = '';
            }
            DevConsoleState.isUnlocked = false;
        }

        function handleDevConsoleUnlock() {
            const { passwordInput, error } = DevConsoleState.elements;
            const value = passwordInput?.value?.trim() || '';

            if (!value) {
                if (error) {
                    error.textContent = 'Password required.';
                }
                return;
            }

            if (value !== DEV_CONSOLE_PASSWORD) {
                if (error) {
                    error.textContent = 'Incorrect password.';
                }
                return;
            }

            DevConsoleState.isUnlocked = true;
            DevConsoleState.unlockExpiresAt = Date.now() + DEV_CONSOLE_UNLOCK_TIMEOUT_MS;
            unlockDevConsoleUI();
        }

        function unlockDevConsoleUI() {
            const { lock, content, passwordInput, error, toggleBtn } = DevConsoleState.elements;
            lock?.classList.add('hidden');
            content?.classList.remove('hidden');
            toggleBtn?.classList.add('is-visible');
            if (error) {
                error.textContent = '';
            }
            if (passwordInput) {
                passwordInput.value = '';
            }
            refreshDevConsoleData();
        }

        function switchDevConsolePanel(panelId) {
            if (!panelId || panelId === DevConsoleState.activePanel) {
                return;
            }

            DevConsoleState.activePanel = panelId;
            const { menu, panels } = DevConsoleState.elements;

            menu?.querySelectorAll('button').forEach(button => {
                const isActive = button.dataset.panel === panelId;
                button.classList.toggle('is-active', isActive);
                button.setAttribute('aria-selected', isActive ? 'true' : 'false');
            });

            panels?.forEach(panel => {
                panel.classList.toggle('is-active', panel.id === `devConsolePanel-${panelId}`);
            });

            if (panelId === 'accounts') {
                renderDevConsoleAccounts();
            } else if (panelId === 'profiles') {
                renderDevConsoleProfiles();
            } else if (panelId === 'riddles') {
                renderDevConsoleRiddles();
            }
        }

        function renderDevConsolePages() {
            const { pageList } = DevConsoleState.elements;
            if (!pageList) {
                return;
            }

            pageList.innerHTML = '';
            DEV_CONSOLE_PAGES.forEach(page => {
                const item = document.createElement('button');
                item.type = 'button';
                item.className = 'dev-console-list-item';
                item.dataset.page = page.id;
                item.innerHTML = `
                    <span class="dev-console-list-title">${page.label}</span>
                    <span class="dev-console-list-subtitle">${page.id}</span>
                `;
                item.addEventListener('click', () => {
                    if (page.id === 'riddle') {
                        renderDevConsoleRiddleSelection();
                    } else if (page.id === 'riddleCompletion') {
                        jumpToRiddleCompletion();
                    } else {
                        hideDevConsole();
                        showPage(page.id);
                    }
                });

                // Highlight logic: check if we're on the right page/state
                let isActive = false;
                if (page.id === 'riddleCompletion') {
                    // Highlight riddleCompletion if we're on riddle page AND showing completion
                    isActive = (currentPage === 'riddle' && isShowingRiddleCompletion);
                } else if (page.id === 'riddle') {
                    // Highlight riddle if we're on riddle page AND NOT showing completion
                    isActive = (currentPage === 'riddle' && !isShowingRiddleCompletion);
                } else {
                    // For other pages, just check currentPage
                    isActive = (currentPage === page.id);
                }
                
                if (isActive) {
                    item.classList.add('is-active');
                }

                pageList.appendChild(item);
            });
        }

        function renderDevConsoleRiddleSelection() {
            const { pageList } = DevConsoleState.elements;
            if (!pageList) {
                return;
            }

            pageList.innerHTML = '';

            // Add back button
            const backButton = document.createElement('button');
            backButton.type = 'button';
            backButton.className = 'dev-console-list-item';
            backButton.innerHTML = `
                <span class="dev-console-list-title">← Back to Pages</span>
                <span class="dev-console-list-subtitle">Return to page list</span>
            `;
            backButton.addEventListener('click', () => {
                renderDevConsolePages();
            });
            pageList.appendChild(backButton);

            // Get all available riddles
            const overrides = loadRiddleOverrides();
            const removed = loadRemovedRiddleIds();
            const customRiddles = loadCustomRiddles();

            const baseRiddles = BASE_RIDDLE_DEFINITIONS
                .filter(riddle => !removed.has(String(riddle.id)))
                .map(riddle => {
                    const override = overrides[riddle.id];
                    return override ? { ...riddle, ...override } : riddle;
                });

            const allRiddles = [...baseRiddles, ...customRiddles];

            // Sort riddles
            allRiddles.sort((a, b) => {
                const idA = String(a.id);
                const idB = String(b.id);
                const isCustomA = idA.startsWith('custom');
                const isCustomB = idB.startsWith('custom');

                if (isCustomA !== isCustomB) {
                    return isCustomA ? 1 : -1;
                }

                const numA = Number(idA);
                const numB = Number(idB);

                if (!Number.isNaN(numA) && !Number.isNaN(numB)) {
                    return numA - numB;
                }

                return idA.localeCompare(idB);
            });

            // Render riddle list
            allRiddles.forEach(riddle => {
                const item = document.createElement('button');
                item.type = 'button';
                item.className = 'dev-console-list-item';
                item.dataset.riddleId = riddle.id;
                
                const riddleTitle = riddle.heading || 'Untitled Riddle';
                const riddleId = riddle.id;
                
                item.innerHTML = `
                    <span class="dev-console-list-title">${riddleTitle}</span>
                    <span class="dev-console-list-subtitle">ID: ${riddleId}</span>
                `;
                
                item.addEventListener('click', () => {
                    jumpToSpecificRiddle(riddle.id);
                });

                pageList.appendChild(item);
            });
        }

        function jumpToSpecificRiddle(riddleId) {
            // Get current user info
            const currentUser = getCurrentUser();
            const playerName = currentUser?.playerName || 'Traveler';
            const variant = localStorage.getItem(FIGURE_VARIANT_KEY) || 'hooded';

            // Build a challenge with just this specific riddle
            const riddleDefinition = RIDDLE_DEFINITION_MAP[riddleId];
            if (!riddleDefinition) {
                console.error('Riddle not found:', riddleId);
                return;
            }

            // Create a challenge with just this one riddle
            activeRiddleChallenge = {
                playerName: playerName,
                index: 0,
                riddles: [riddleDefinition],
                completed: false,
                variant: variant
            };

            // Save and navigate
            saveActiveChallenge();
            hideDevConsole();
            showPage('riddle');
        }

        function jumpToRiddleCompletion() {
            // Get current user info
            const currentUser = getCurrentUser();
            const playerName = currentUser?.playerName || 'Traveler';
            const variant = localStorage.getItem(FIGURE_VARIANT_KEY) || 'hooded';
            const profileId = localStorage.getItem(SELECTED_PROFILE_KEY);

            // Create a completed challenge to show the completion screen
            activeRiddleChallenge = {
                playerName: playerName,
                index: 0,
                riddles: [RIDDLE_DEFINITION_MAP[INTRO_RIDDLE_ID]], // Just need one riddle
                completed: true,
                variant: variant,
                profileId: profileId
            };

            // Save and navigate
            saveActiveChallenge();
            showPage('riddle');
            // Dev console highlighting will be updated automatically by renderChallengeCompletion()
        }

        function parseAccountsFromStorage() {
            try {
                return JSON.parse(localStorage.getItem('accounts') || '{}');
            } catch (error) {
                return {};
            }
        }

        function renderDevConsoleAccounts() {
            const { accountsTableBody, accountsSummary } = DevConsoleState.elements;
            if (!accountsTableBody) {
                return;
            }

            const accounts = parseAccountsFromStorage();
            const currentUserEmail = localStorage.getItem('currentUser');
            accountsTableBody.innerHTML = '';

            const entries = Object.entries(accounts);
            entries.forEach(([email, account]) => {
                const row = document.createElement('tr');
                if (email === currentUserEmail) {
                    row.classList.add('is-current');
                }

                const safeAccount = account || {};
                const createdAt = safeAccount.createdAt ? new Date(safeAccount.createdAt).toLocaleString() : '—';
                row.innerHTML = `
                    <td>${email}</td>
                    <td>${safeAccount.password || '—'}</td>
                    <td>${safeAccount.playerName || '—'}</td>
                    <td>${safeAccount.provider || 'local'}</td>
                    <td>${createdAt}</td>
                    <td>
                        <div class="dev-console-inline-actions">
                            <button type="button" class="dev-console-tertiary" data-action="reset" data-email="${email}">Reset Progress</button>
                            <button type="button" class="dev-console-tertiary danger" data-action="delete" data-email="${email}">Delete</button>
                        </div>
                    </td>
                `;
                accountsTableBody.appendChild(row);
            });

            accountsTableBody.querySelectorAll('button[data-action="reset"]').forEach(button => {
                button.addEventListener('click', () => handleAccountReset(button.dataset.email));
            });

            accountsTableBody.querySelectorAll('button[data-action="delete"]').forEach(button => {
                button.addEventListener('click', () => handleAccountDelete(button.dataset.email));
            });

            if (accountsSummary) {
                if (!entries.length) {
                    accountsSummary.textContent = 'No accounts found in local storage.';
                } else {
                    accountsSummary.textContent = `${entries.length} account${entries.length === 1 ? '' : 's'} stored. Current user: ${currentUserEmail || 'none'}.`;
                }
            }
        }

        function handleAccountDelete(email) {
            if (!email) {
                return;
            }

            const accounts = parseAccountsFromStorage();
            if (!accounts[email]) {
                return;
            }

            delete accounts[email];
            localStorage.setItem('accounts', JSON.stringify(accounts));

            if (localStorage.getItem('currentUser') === email) {
                localStorage.removeItem('currentUser');
                clearActiveChallengeState();
                showPage('login');
            }

            renderDevConsoleAccounts();
            refreshDevConsolePagesActiveState();
        }

        function handleAccountReset(email) {
            if (!email) {
                return;
            }

            const accounts = parseAccountsFromStorage();
            const account = accounts[email];
            if (!account) {
                return;
            }

            account.playerName = null;
            account.riddleAnswer = null;
            accounts[email] = account;
            localStorage.setItem('accounts', JSON.stringify(accounts));

            if (localStorage.getItem('currentUser') === email) {
                clearActiveChallengeState();
                showPage('login');
            }

            renderDevConsoleAccounts();
            refreshDevConsolePagesActiveState();
        }

        function handleClearAllAccounts() {
            const accounts = parseAccountsFromStorage();
            if (!Object.keys(accounts).length) {
                return;
            }

            localStorage.removeItem('accounts');
            localStorage.removeItem('currentUser');
            clearActiveChallengeState();
            showPage('login');
            renderDevConsoleAccounts();
            refreshDevConsolePagesActiveState();
        }

        function loadCustomRiddles() {
            try {
                const stored = JSON.parse(localStorage.getItem(DEV_CONSOLE_STORAGE_KEY) || '[]');
                if (!Array.isArray(stored)) {
                    return [];
                }
                return stored.filter(riddle => riddle && typeof riddle === 'object');
            } catch (error) {
                return [];
            }
        }

        function saveCustomRiddles(riddles) {
            localStorage.setItem(DEV_CONSOLE_STORAGE_KEY, JSON.stringify(riddles));
        }

        function loadRiddleOverrides() {
            try {
                const stored = JSON.parse(localStorage.getItem(DEV_CONSOLE_RIDDLE_OVERRIDES_KEY) || '{}');
                return stored && typeof stored === 'object' ? stored : {};
            } catch (error) {
                return {};
            }
        }

        function saveRiddleOverrides(overrides) {
            localStorage.setItem(DEV_CONSOLE_RIDDLE_OVERRIDES_KEY, JSON.stringify(overrides || {}));
        }

        function loadRemovedRiddleIds() {
            try {
                const stored = JSON.parse(localStorage.getItem(DEV_CONSOLE_REMOVED_RIDDLES_KEY) || '[]');
                return Array.isArray(stored) ? new Set(stored.map(String)) : new Set();
            } catch (error) {
                return new Set();
            }
        }

        function saveRemovedRiddleIds(set) {
            const values = Array.from(set || new Set());
            localStorage.setItem(DEV_CONSOLE_REMOVED_RIDDLES_KEY, JSON.stringify(values));
        }

        function loadInteractiveRiddleIds() {
            try {
                const stored = JSON.parse(localStorage.getItem(DEV_CONSOLE_INTERACTIVE_RIDDLES_KEY) || 'null');
                if (Array.isArray(stored)) {
                    return new Set(stored.map(Number));
                }
                // Default: return the 3 original interactive riddles
                return new Set(DEFAULT_INTERACTIVE_RIDDLE_IDS);
            } catch (error) {
                return new Set(DEFAULT_INTERACTIVE_RIDDLE_IDS);
            }
        }

        function saveInteractiveRiddleIds(set) {
            const values = Array.from(set || new Set());
            localStorage.setItem(DEV_CONSOLE_INTERACTIVE_RIDDLES_KEY, JSON.stringify(values));
        }

        function normalizeCustomAnswers(input) {
            return (input || '')
                .split(',')
                .map(answer => answer.trim())
                .filter(Boolean);
        }

        function createCustomRiddleDefinition({ name, question, answers, signature, white }) {
            const trimmedQuestion = question.trim();
            const trimmedName = name?.trim() || 'Custom Riddle';
            if (!trimmedQuestion || !answers.length) {
                return null;
            }

            const id = `custom-${Date.now()}`;
            const whiteLines = white ? white.split('\n').map(line => line.trim()).filter(Boolean) : [];
            
            // Handle signature: allow empty string, null, undefined -> use default only if undefined
            let finalSignature = signature;
            if (signature === undefined || signature === null) {
                finalSignature = '- Dev Console';
            }
            
            return {
                id,
                heading: trimmedName,
                white: whiteLines.length > 0 ? whiteLines : ['A custom riddle added via dev console.'],
                yellow: trimmedQuestion,
                answers,
                signature: finalSignature,
                isCustom: true
            };
        }

        function handleDevConsoleRiddleSubmit(event) {
            event.preventDefault();
            const {
                riddleName,
                riddleWhite,
                riddleQuestion,
                riddleAnswers,
                riddleSignature,
                riddleFeedback
            } = DevConsoleState.elements;

            if (!riddleName || !riddleQuestion || !riddleAnswers) {
                return;
            }

            const name = riddleName.value;
            const white = riddleWhite?.value || '';
            const question = riddleQuestion.value;
            const answers = normalizeCustomAnswers(riddleAnswers.value).map(answer => answer.toLowerCase());
            const signature = riddleSignature?.value !== undefined ? riddleSignature.value : '';

            if (!name.trim() || !question.trim() || !answers.length) {
                if (riddleFeedback) {
                    riddleFeedback.textContent = 'Name, question, and at least one answer are required.';
                    riddleFeedback.className = 'dev-console-feedback error';
                }
                return;
            }

            const customRiddle = createCustomRiddleDefinition({ name, white, question, answers, signature });
            if (!customRiddle) {
                if (riddleFeedback) {
                    riddleFeedback.textContent = 'Unable to create riddle. Check your inputs and try again.';
                    riddleFeedback.className = 'dev-console-feedback error';
                }
                return;
            }

            const riddles = loadCustomRiddles();
            riddles.push(customRiddle);
            saveCustomRiddles(riddles);

            integrateCustomRiddle(customRiddle);
            renderDevConsoleRiddles();

            if (riddleFeedback) {
                riddleFeedback.textContent = 'Riddle saved successfully.';
                riddleFeedback.className = 'dev-console-feedback success';
            }

            riddleName.value = '';
            if (riddleWhite) {
                riddleWhite.value = '';
            }
            riddleQuestion.value = '';
            riddleAnswers.value = '';
            if (riddleSignature) {
                riddleSignature.value = '';
            }

            updateDevConsoleRiddleFeedback(true, `Custom riddle ${customRiddle.id} added.`);
        }

        function resetDevConsoleRiddleForm() {
            const {
                riddleName,
                riddleWhite,
                riddleQuestion,
                riddleAnswers,
                riddleSignature,
                riddleFeedback
            } = DevConsoleState.elements;

            if (riddleName) {
                riddleName.value = '';
            }
            if (riddleWhite) {
                riddleWhite.value = '';
            }
            if (riddleQuestion) {
                riddleQuestion.value = '';
            }
            if (riddleAnswers) {
                riddleAnswers.value = '';
            }
            if (riddleSignature) {
                riddleSignature.value = '';
            }
            if (riddleFeedback) {
                riddleFeedback.textContent = '';
                riddleFeedback.className = 'dev-console-feedback';
            }

            updateDevConsoleRiddleFeedback(false, 'Riddle form reset.');
        }

        function integrateCustomRiddle(customRiddle) {
            if (!customRiddle) {
                return;
            }

            const normalizedAnswers = new Set((customRiddle.answers || []).map(normalizeAnswer).filter(Boolean));
            const definition = { ...customRiddle, normalizedAnswers };
            refreshRiddleDefinition(definition);
        }

        function renderDevConsoleRiddles() {
            const { riddleList } = DevConsoleState.elements;
            if (!riddleList) {
                return;
            }

            riddleList.innerHTML = '';

            const overrides = loadRiddleOverrides();
            const removed = loadRemovedRiddleIds();

            const baseRiddles = BASE_RIDDLE_DEFINITIONS
                .filter(riddle => !removed.has(String(riddle.id)))
                .map(riddle => {
                    const override = overrides[riddle.id];
                    const merged = override ? {
                        ...riddle,
                        ...override,
                        answers: override.answers || riddle.answers,
                        white: override.white || riddle.white,
                        yellow: override.yellow ?? riddle.yellow,
                        heading: override.heading ?? riddle.heading,
                        signature: override.signature !== undefined ? override.signature : riddle.signature
                    } : riddle;

                    return {
                        id: merged.id,
                        heading: merged.heading,
                        yellow: merged.yellow,
                        answers: Array.from(new Set((merged.answers || []).map(normalizeAnswer))).map(answer => answer),
                        white: Array.isArray(merged.white) ? merged.white : (merged.white ? [merged.white] : []),
                        signature: merged.signature,
                        isCustom: Boolean(override)
                    };
                });

            const customRiddles = loadCustomRiddles().map(riddle => ({
                ...riddle,
                answers: Array.from(new Set((riddle.answers || []).map(normalizeAnswer))),
                white: Array.isArray(riddle.white) ? riddle.white : (riddle.white ? [riddle.white] : []),
                isCustom: true
            }));

            const allRiddles = [...baseRiddles, ...customRiddles];

            allRiddles.sort((a, b) => {
                const idA = String(a.id);
                const idB = String(b.id);

                const isCustomA = idA.startsWith('custom');
                const isCustomB = idB.startsWith('custom');

                if (isCustomA !== isCustomB) {
                    return isCustomA ? 1 : -1;
                }

                const numA = Number(idA);
                const numB = Number(idB);

                if (!Number.isNaN(numA) && !Number.isNaN(numB)) {
                    return numA - numB;
                }

                return idA.localeCompare(idB, undefined, { sensitivity: 'base' });
            });

            allRiddles.forEach(riddle => {
                const item = document.createElement('div');
                item.className = `dev-console-riddle-item${riddle.isCustom ? ' is-custom' : ''}`;
                const heading = riddle.heading || '—';
                const yellow = riddle.yellow || '—';
                const white = (riddle.white && riddle.white.join(' ')) || '—';
                const answerList = (riddle.answers || []).join(', ') || '—';
                const rawSignature = riddle.signature || '';
                
                // Check if this riddle is interactive
                const interactiveIds = loadInteractiveRiddleIds();
                const isInteractive = interactiveIds.has(riddle.id);
                const isDefault = DEFAULT_INTERACTIVE_RIDDLE_IDS.includes(riddle.id);
                const canBeInteractive = riddle.id !== INTRO_RIDDLE_ID && riddle.id !== SECOND_RIDDLE_ID;
                
                // Display signature: show what it will be
                let displaySignature = rawSignature;
                if (rawSignature === '<default>') {
                    displaySignature = '<default> (Uses chosen character)';
                } else if (rawSignature === '') {
                    displaySignature = '';
                }
                const signature = rawSignature;
                
                // Build signature dropdown options
                const profiles = loadProfiles();
                const currentUser = getCurrentUser();
                const playerName = currentUser?.playerName || 'Player';
                const noneSelected = (!signature || signature === '') ? 'selected' : '';
                const defaultSelected = (signature === '<default>') ? 'selected' : '';
                const signatureOptions = [
                    `<option value="" ${noneSelected}>None</option>`, 
                    `<option value="<default>" ${defaultSelected}>Default (player's choice)</option>`
                ];
                profiles.forEach(profile => {
                    const selected = profile.signature === signature ? 'selected' : '';
                    const displayText = profile.isPlayer ? `${profile.name} (- ${playerName})` : `${profile.name} (${profile.signature})`;
                    signatureOptions.push(`<option value="${profile.signature.replace(/"/g, '&quot;')}" ${selected}>${displayText}</option>`);
                });

                item.innerHTML = `
                    <div class="dev-console-riddle-title">
                        <strong>Title:</strong> ${heading}
                        ${riddle.isCustom ? '<span class="dev-console-tag" style="margin-left: 0.5rem;">Custom</span>' : ''}
                        ${isDefault ? '<span class="dev-console-tag" style="margin-left: 0.5rem; background: rgba(214, 165, 80, 0.2); color: #d6a550;">Default Interactive</span>' : ''}
                    </div>
                    <div class="dev-console-riddle-meta">
                        <span>ID: ${riddle.id}</span>
                    </div>
                    ${canBeInteractive ? `<div class="dev-console-riddle-section">
                        <label style="display: flex; align-items: center; cursor: pointer; user-select: none;">
                            <input type="checkbox" ${isInteractive ? 'checked' : ''} data-interactive-toggle="${riddle.id}" style="margin-right: 0.5rem; width: 1rem; height: 1rem; cursor: pointer;">
                            <strong>Interactive (XL Lightbox)</strong>
                        </label>
                    </div>` : ''}
                    <div class="dev-console-riddle-section">
                        <strong>White Dialog:</strong>
                        <div class="dev-console-riddle-content">${white}</div>
                    </div>
                    <div class="dev-console-riddle-section">
                        <strong>Yellow Dialog:</strong>
                        <div class="dev-console-riddle-content" style="color: #d6a550;">${yellow}</div>
                    </div>
                    <div class="dev-console-riddle-section">
                        <strong>Signature:</strong>
                        <div class="dev-console-riddle-content">${displaySignature || '<em>None</em>'}</div>
                    </div>
                    <div class="dev-console-riddle-section">
                        <strong>Answers:</strong>
                        <div class="dev-console-riddle-content">${answerList}</div>
                    </div>
                    <div class="dev-console-riddle-actions">
                        <button type="button" class="dev-console-tertiary" data-action="edit" data-riddle="${riddle.id}">Edit</button>
                        <button type="button" class="dev-console-tertiary danger" data-action="delete" data-riddle="${riddle.id}">Delete</button>
                    </div>
                    <div class="dev-console-riddle-editor" id="devConsoleRiddleEditor-${riddle.id}">
                        <label>
                            Heading <span style="color: rgba(249, 235, 225, 0.5); font-size: 0.75rem;">(wraps at ~30 chars per line)</span>
                            <input type="text" class="dev-console-input" data-field="heading" value="${heading.replace(/"/g, '&quot;')}">
                        </label>
                        <label>
                            Narrative (white, one per line)
                            <textarea class="dev-console-textarea" data-field="white">${(riddle.white || []).join('\n')}</textarea>
                        </label>
                        <label>
                            Question (yellow)
                            <textarea class="dev-console-textarea" data-field="yellow">${yellow}</textarea>
                        </label>
                        <label>
                            Answers (comma separated)
                            <input type="text" class="dev-console-input" data-field="answers" value="${answerList}">
                        </label>
                        <label>
                            Signature
                            <select class="dev-console-input" data-field="signature">
                                ${signatureOptions.join('')}
                            </select>
                        </label>
                        ${canBeInteractive ? `<label style="display: flex; align-items: center; cursor: pointer; user-select: none; margin-top: 0.625rem;">
                            <input type="checkbox" ${isInteractive ? 'checked' : ''} data-interactive-toggle-edit="${riddle.id}" style="margin-right: 0.5rem; width: 1rem; height: 1rem; cursor: pointer;">
                            <strong>Interactive (XL Lightbox)</strong>
                        </label>` : ''}
                        <div class="dev-console-inline-actions">
                            <button type="button" class="dev-console-tertiary" data-action="save" data-riddle="${riddle.id}">Save</button>
                            <button type="button" class="dev-console-tertiary" data-action="cancel" data-riddle="${riddle.id}">Cancel</button>
                        </div>
                    </div>
                `;
                riddleList.appendChild(item);
            });

            if (!allRiddles.length) {
                const muted = document.createElement('div');
                muted.className = 'dev-console-muted';
                muted.textContent = 'No riddles found.';
                riddleList.appendChild(muted);
            }

            riddleList.querySelectorAll('button[data-action="edit"]').forEach(button => {
                button.addEventListener('click', () => showRiddleEditor(button.dataset.riddle));
            });

            riddleList.querySelectorAll('button[data-action="delete"]').forEach(button => {
                button.addEventListener('click', () => deleteRiddle(button.dataset.riddle));
            });

            riddleList.querySelectorAll('button[data-action="save"]').forEach(button => {
                button.addEventListener('click', () => saveRiddleEdits(button.dataset.riddle));
            });

            riddleList.querySelectorAll('button[data-action="cancel"]').forEach(button => {
                button.addEventListener('click', () => hideRiddleEditor(button.dataset.riddle));
            });

            // Add event listeners for interactive toggles (view mode)
            riddleList.querySelectorAll('input[data-interactive-toggle]').forEach(checkbox => {
                checkbox.addEventListener('change', function() {
                    const riddleId = Number(this.dataset.interactiveToggle);
                    const currentIds = loadInteractiveRiddleIds();
                    
                    if (this.checked) {
                        currentIds.add(riddleId);
                    } else {
                        currentIds.delete(riddleId);
                    }
                    
                    saveInteractiveRiddleIds(currentIds);
                    
                    // Update the corresponding edit mode checkbox
                    const editCheckbox = riddleList.querySelector(`input[data-interactive-toggle-edit="${riddleId}"]`);
                    if (editCheckbox) {
                        editCheckbox.checked = this.checked;
                    }
                });
            });

            // Add event listeners for interactive toggles (edit mode)
            riddleList.querySelectorAll('input[data-interactive-toggle-edit]').forEach(checkbox => {
                checkbox.addEventListener('change', function() {
                    const riddleId = Number(this.dataset.interactiveToggleEdit);
                    const currentIds = loadInteractiveRiddleIds();
                    
                    if (this.checked) {
                        currentIds.add(riddleId);
                    } else {
                        currentIds.delete(riddleId);
                    }
                    
                    saveInteractiveRiddleIds(currentIds);
                    
                    // Update the corresponding view mode checkbox
                    const viewCheckbox = riddleList.querySelector(`input[data-interactive-toggle="${riddleId}"]`);
                    if (viewCheckbox) {
                        viewCheckbox.checked = this.checked;
                    }
                });
            });
        }

        function refreshDevConsoleData() {
            renderDevConsolePages();
            refreshDevConsolePagesActiveState();
            if (DevConsoleState.activePanel === 'accounts') {
                renderDevConsoleAccounts();
            } else if (DevConsoleState.activePanel === 'profiles') {
                renderDevConsoleProfiles();
            } else if (DevConsoleState.activePanel === 'riddles') {
                renderDevConsoleRiddles();
            }
        }

        // Profile management functions
        function populateSignatureDropdown() {
            const { riddleSignature } = DevConsoleState.elements;
            if (!riddleSignature) return;

            const profiles = loadProfiles();
            const currentValue = riddleSignature.value;
            const currentUser = getCurrentUser();
            const playerName = currentUser?.playerName || 'Player';

            // Clear existing options except None and Default
            while (riddleSignature.options.length > 2) {
                riddleSignature.remove(2);
            }

            // Add profile options
            profiles.forEach(profile => {
                const option = document.createElement('option');
                if (profile.isPlayer) {
                    // For player profile, use the actual player name
                    option.value = profile.signature;
                    option.textContent = `${profile.name} (- ${playerName})`;
                } else {
                    option.value = profile.signature;
                    option.textContent = `${profile.name} (${profile.signature})`;
                }
                riddleSignature.appendChild(option);
            });

            // Restore previous value if it exists
            if (currentValue) {
                riddleSignature.value = currentValue;
            }
        }

        function renderDevConsoleProfiles() {
            const { profileList } = DevConsoleState.elements;
            if (!profileList) return;

            profileList.innerHTML = '';
            const profiles = loadProfiles();

            profiles.forEach(profile => {
                const item = document.createElement('div');
                item.className = 'dev-console-riddle-item';
                
                item.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 0.75rem; margin-bottom: 0.75rem;">
                        ${profile.bust ? `<img src="${profile.bust}" alt="${profile.name}" style="width: 3.75rem; height: 3.75rem; object-fit: cover; border-radius: 0.5rem; border: 0.0625rem solid rgba(214, 165, 80, 0.4);">` : '<div style="width: 3.75rem; height: 3.75rem; background: rgba(24, 18, 12, 0.6); border-radius: 0.5rem; border: 0.0625rem solid rgba(214, 165, 80, 0.4); display: flex; align-items: center; justify-content: center; color: rgba(249, 235, 225, 0.4); font-size: 0.75rem;">No Image</div>'}
                        <div style="flex: 1;">
                            <div class="dev-console-riddle-title">${profile.name}</div>
                            <div class="dev-console-riddle-meta">
                                <span>Signature: ${profile.signature}</span>
                                ${profile.password ? `<span>Password: ${profile.password}</span>` : ''}
                            </div>
                        </div>
                    </div>
                    <div class="dev-console-riddle-section">
                        <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; color: #f4e3c1;">
                            <input type="checkbox" ${profile.enabledAsPassword ? 'checked' : ''} onchange="toggleProfilePassword('${profile.id}', this.checked)" ${profile.isDefault && profile.id === 'mysterious-figure' ? '' : ''}>
                            <span>Enable as password on "who can we trust" screen</span>
                        </label>
                    </div>
                    <div class="dev-console-riddle-actions">
                        ${profile.isDefault ? `<button type="button" class="dev-console-tertiary" onclick="editProfile('${profile.id}')">Edit</button>` : ''}
                        ${!profile.isDefault ? `<button type="button" class="dev-console-tertiary" onclick="editProfile('${profile.id}')">Edit</button>` : ''}
                        ${!profile.isDefault ? `<button type="button" class="dev-console-tertiary danger" onclick="deleteProfile('${profile.id}')">Delete</button>` : ''}
                    </div>
                `;
                profileList.appendChild(item);
            });

            if (!profiles.length) {
                const muted = document.createElement('div');
                muted.className = 'dev-console-muted';
                muted.textContent = 'No profiles found.';
                profileList.appendChild(muted);
            }
        }

        function toggleProfilePassword(profileId, enabled) {
            const profiles = loadProfiles();
            const profile = profiles.find(p => p.id === profileId);
            if (profile) {
                profile.enabledAsPassword = enabled;
                saveProfiles(profiles);
            }
        }

        function showAddProfileForm() {
            DevConsoleState.editingProfileId = null;
            const { profileEditor, profileEditorTitle } = DevConsoleState.elements;
            
            if (profileEditor && profileEditorTitle) {
                profileEditorTitle.textContent = 'Add New Profile';
                resetProfileFormFields();
                profileEditor.style.display = 'block';
                profileEditor.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }
        }

        function hideProfileEditor() {
            const { profileEditor } = DevConsoleState.elements;
            if (profileEditor) {
                profileEditor.style.display = 'none';
                resetProfileFormFields();
                DevConsoleState.editingProfileId = null;
                DevConsoleState.profileImageData = null;
            }
        }

        function resetProfileFormFields() {
            const {
                profileName,
                profileSignature,
                profilePassword,
                profileEnabled,
                profileImageName,
                profileImagePreview,
                profileFormFeedback
            } = DevConsoleState.elements;

            if (profileName) {
                profileName.value = '';
                profileName.disabled = false;
            }
            if (profileSignature) {
                profileSignature.value = '';
                profileSignature.disabled = false;
            }
            if (profilePassword) profilePassword.value = '';
            if (profileEnabled) profileEnabled.checked = false;
            if (profileImageName) profileImageName.textContent = 'No image selected';
            if (profileImagePreview) profileImagePreview.style.display = 'none';
            if (profileFormFeedback) {
                profileFormFeedback.textContent = '';
                profileFormFeedback.className = 'dev-console-feedback';
            }
            DevConsoleState.profileImageData = null;
        }

        function handleProfileImageSelection(event) {
            const file = event.target.files?.[0];
            if (!file) return;

            const { profileImageName, profileImagePreview, profileImagePreviewImg } = DevConsoleState.elements;

            const reader = new FileReader();
            reader.onload = (e) => {
                DevConsoleState.profileImageData = e.target.result;
                if (profileImageName) profileImageName.textContent = file.name;
                if (profileImagePreview) profileImagePreview.style.display = 'block';
                if (profileImagePreviewImg) profileImagePreviewImg.src = e.target.result;
            };
            reader.readAsDataURL(file);
            event.target.value = '';
        }

        function handleProfileFormSubmit(event) {
            event.preventDefault();

            const {
                profileName,
                profileSignature,
                profilePassword,
                profileEnabled,
                profileFormFeedback
            } = DevConsoleState.elements;

            const name = profileName?.value.trim();
            const signature = profileSignature?.value.trim();
            const password = profilePassword?.value.trim();
            const enabled = profileEnabled?.checked || false;

            if (!name || !signature) {
                if (profileFormFeedback) {
                    profileFormFeedback.textContent = 'Profile name and signature are required.';
                    profileFormFeedback.className = 'dev-console-feedback error';
                }
                return;
            }

            const profiles = loadProfiles();

            if (DevConsoleState.editingProfileId) {
                // Edit existing profile
                const profile = profiles.find(p => p.id === DevConsoleState.editingProfileId);
                if (profile) {
                    // For default profiles, only allow password, enabledAsPassword, and bust changes
                    if (profile.isDefault) {
                        profile.password = password.toLowerCase();
                        profile.enabledAsPassword = enabled;
                        if (DevConsoleState.profileImageData) {
                            profile.bust = DevConsoleState.profileImageData;
                        }
                    } else {
                        // For custom profiles, allow all changes
                        profile.name = name;
                        profile.signature = signature;
                        profile.password = password.toLowerCase();
                        profile.enabledAsPassword = enabled;
                        if (DevConsoleState.profileImageData) {
                            profile.bust = DevConsoleState.profileImageData;
                        }
                    }
                }
            } else {
                // Add new profile
                const newProfile = {
                    id: `custom-profile-${Date.now()}`,
                    name,
                    signature,
                    bust: DevConsoleState.profileImageData || '',
                    password: password.toLowerCase(),
                    enabledAsPassword: enabled,
                    isDefault: false
                };
                profiles.push(newProfile);
            }

            saveProfiles(profiles);
            renderDevConsoleProfiles();
            populateSignatureDropdown();
            hideProfileEditor();

            const { profileFeedback } = DevConsoleState.elements;
            if (profileFeedback) {
                profileFeedback.textContent = DevConsoleState.editingProfileId ? 'Profile updated successfully.' : `Profile "${name}" created successfully.`;
                profileFeedback.className = 'dev-console-feedback success';
                setTimeout(() => {
                    profileFeedback.textContent = '';
                    profileFeedback.className = 'dev-console-feedback';
                }, 3000);
            }
        }

        function editProfile(profileId) {
            const profiles = loadProfiles();
            const profile = profiles.find(p => p.id === profileId);
            if (!profile) return;

            if (profile.isPlayer) {
                // For player profile, only allow image upload
                DevConsoleState.editingProfileId = profileId;
                DevConsoleState.elements.profileImageInput?.click();
                
                // Handle the image upload for player profile
                const originalHandler = DevConsoleState.elements.profileImageInput?.onchange;
                DevConsoleState.elements.profileImageInput.onchange = (e) => {
                    const file = e.target.files?.[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = (evt) => {
                            profile.bust = evt.target.result;
                            saveProfiles(profiles);
                            renderDevConsoleProfiles();
                            
                            const { profileFeedback } = DevConsoleState.elements;
                            if (profileFeedback) {
                                profileFeedback.textContent = 'Player bust image updated successfully.';
                                profileFeedback.className = 'dev-console-feedback success';
                                setTimeout(() => {
                                    profileFeedback.textContent = '';
                                    profileFeedback.className = 'dev-console-feedback';
                                }, 3000);
                            }
                        };
                        reader.readAsDataURL(file);
                    }
                    e.target.value = '';
                    // Restore normal handler
                    if (originalHandler) {
                        DevConsoleState.elements.profileImageInput.onchange = originalHandler;
                    }
                };
            } else {
                // Edit any profile (custom or default) with form
                DevConsoleState.editingProfileId = profileId;
                const { 
                    profileEditor, 
                    profileEditorTitle,
                    profileName,
                    profileSignature,
                    profilePassword,
                    profileEnabled,
                    profileImageName,
                    profileImagePreview,
                    profileImagePreviewImg
                } = DevConsoleState.elements;

                if (profileEditor && profileEditorTitle) {
                    profileEditorTitle.textContent = profile.isDefault ? 'Edit Default Profile' : 'Edit Profile';
                    if (profileName) {
                        profileName.value = profile.name;
                        profileName.disabled = profile.isDefault; // Lock name for default profiles
                    }
                    if (profileSignature) {
                        profileSignature.value = profile.signature;
                        profileSignature.disabled = profile.isDefault; // Lock signature for default profiles
                    }
                    if (profilePassword) {
                        profilePassword.value = profile.password;
                    }
                    if (profileEnabled) {
                        profileEnabled.checked = profile.enabledAsPassword;
                    }
                    
                    if (profile.bust) {
                        DevConsoleState.profileImageData = profile.bust;
                        if (profileImageName) profileImageName.textContent = 'Current image';
                        if (profileImagePreview) profileImagePreview.style.display = 'block';
                        if (profileImagePreviewImg) profileImagePreviewImg.src = profile.bust;
                    }

                    profileEditor.style.display = 'block';
                    profileEditor.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }
            }
        }

        function deleteProfile(profileId) {
            if (!confirm('Are you sure you want to delete this profile?')) return;

            let profiles = loadProfiles();
            profiles = profiles.filter(p => p.id !== profileId);
            saveProfiles(profiles);
            renderDevConsoleProfiles();
            populateSignatureDropdown();

            const { profileFeedback } = DevConsoleState.elements;
            if (profileFeedback) {
                profileFeedback.textContent = 'Profile deleted successfully.';
                profileFeedback.className = 'dev-console-feedback success';
                setTimeout(() => {
                    profileFeedback.textContent = '';
                    profileFeedback.className = 'dev-console-feedback';
                }, 3000);
            }
        }

        // Make functions globally available
        window.toggleProfilePassword = toggleProfilePassword;
        window.editProfile = editProfile;
        window.deleteProfile = deleteProfile;

        function restoreCustomRiddles() {
            Object.keys(RIDDLE_DEFINITION_MAP).forEach(key => {
                if (!BASE_RIDDLE_DEFINITIONS.some(base => String(base.id) === String(key))) {
                    delete RIDDLE_DEFINITION_MAP[key];
                }
            });

            RIDDLE_DEFINITIONS.length = 0;
            BASE_RIDDLE_DEFINITIONS.forEach(def => {
                const normalizedAnswers = new Set((def.answers || []).map(normalizeAnswer).filter(Boolean));
                const clone = { ...def, normalizedAnswers };
                RIDDLE_DEFINITION_MAP[def.id] = clone;
                RIDDLE_DEFINITIONS.push(clone);
            });

            const overrides = loadRiddleOverrides();
            Object.entries(overrides).forEach(([id, override]) => {
                const base = RIDDLE_DEFINITION_MAP[id];
                if (!base) {
                    return;
                }

                const merged = {
                    ...base,
                    ...override,
                    answers: override.answers || base.answers,
                    white: override.white || base.white,
                    yellow: override.yellow ?? base.yellow,
                    heading: override.heading ?? base.heading,
                    signature: override.signature !== undefined ? override.signature : base.signature,
                    isCustom: Boolean(base.isCustom || override.isCustom)
                };

                merged.normalizedAnswers = new Set((merged.answers || []).map(normalizeAnswer).filter(Boolean));
                refreshRiddleDefinition(merged);
            });

            const removed = loadRemovedRiddleIds();
            removed.forEach(id => {
                delete RIDDLE_DEFINITION_MAP[id];
            });

            for (let i = RIDDLE_DEFINITIONS.length - 1; i >= 0; i -= 1) {
                if (!RIDDLE_DEFINITION_MAP[RIDDLE_DEFINITIONS[i].id]) {
                    RIDDLE_DEFINITIONS.splice(i, 1);
                }
            }

            const stored = loadCustomRiddles();
            stored.forEach(integrateCustomRiddle);
        }

        function updateDevConsoleRiddleFeedback(isSuccess, message) {
            const { riddleFeedback } = DevConsoleState.elements;
            if (!riddleFeedback) {
                return;
            }

            riddleFeedback.textContent = message || '';
            riddleFeedback.className = 'dev-console-feedback';

            if (!message) {
                return;
            }

            if (isSuccess) {
                riddleFeedback.classList.add('success');
            } else {
                riddleFeedback.classList.add('error');
            }
        }

        function showRiddleEditor(riddleId) {
            if (!riddleId) {
                return;
            }

            const editor = document.getElementById(`devConsoleRiddleEditor-${riddleId}`);
            if (!editor) {
                return;
            }

            editor.classList.add('is-visible');
        }

        function hideRiddleEditor(riddleId) {
            if (!riddleId) {
                return;
            }

            const editor = document.getElementById(`devConsoleRiddleEditor-${riddleId}`);
            if (!editor) {
                return;
            }

            editor.classList.remove('is-visible');
        }

        function collectRiddleEditorValues(riddleId) {
            const editor = document.getElementById(`devConsoleRiddleEditor-${riddleId}`);
            if (!editor) {
                return null;
            }

            const heading = editor.querySelector('[data-field="heading"]').value.trim();
            const yellow = editor.querySelector('[data-field="yellow"]').value.trim();
            const whiteRaw = editor.querySelector('[data-field="white"]').value
                .split('\n')
                .map(line => line.trim())
                .filter(Boolean);
            const answers = normalizeCustomAnswers(editor.querySelector('[data-field="answers"]').value);
            const signatureField = editor.querySelector('[data-field="signature"]');
            const signature = signatureField ? signatureField.value : '';

            return {
                heading,
                yellow,
                white: whiteRaw,
                answers,
                signature
            };
        }

        function saveRiddleEdits(riddleId) {
            if (!riddleId) {
                return;
            }

            const values = collectRiddleEditorValues(riddleId);
            if (!values) {
                return;
            }

            if (!values.heading || !values.yellow || !values.answers.length) {
                updateDevConsoleRiddleFeedback(false, 'Heading, question, and answers are required.');
                return;
            }

            const normalizedAnswersArray = values.answers.map(normalizeAnswer).filter(Boolean);
            if (!normalizedAnswersArray.length) {
                updateDevConsoleRiddleFeedback(false, 'At least one valid answer is required.');
                return;
            }

            const overrides = loadRiddleOverrides();
            const removed = loadRemovedRiddleIds();
            const customRiddles = loadCustomRiddles();
            const isCustom = String(riddleId).startsWith('custom');

            if (isCustom) {
                const updatedCustom = customRiddles.map(riddle => {
                    if (String(riddle.id) !== String(riddleId)) {
                        return riddle;
                    }
                    return {
                        ...riddle,
                        heading: values.heading,
                        yellow: values.yellow,
                        white: values.white,
                        answers: values.answers,
                        signature: values.signature || riddle.signature || '- Dev Console'
                    };
                });
                saveCustomRiddles(updatedCustom);

                const baseDefinition = RIDDLE_DEFINITION_MAP[riddleId] || {};
            const definition = {
                    ...baseDefinition,
                    id: riddleId,
                    heading: values.heading,
                    yellow: values.yellow,
                    white: values.white,
                    signature: values.signature || baseDefinition.signature || '- Dev Console',
                    answers: values.answers,
                    normalizedAnswers: new Set(normalizedAnswersArray),
                    isCustom: true
                };
                refreshRiddleDefinition(definition);
            } else {
                removed.delete(String(riddleId));
                saveRemovedRiddleIds(removed);

                overrides[riddleId] = {
                    heading: values.heading,
                    yellow: values.yellow,
                    white: values.white,
                    answers: values.answers,
                    signature: values.signature !== undefined ? values.signature : ''
                };
                saveRiddleOverrides(overrides);

                const baseDefinition = BASE_RIDDLE_DEFINITIONS.find(riddle => String(riddle.id) === String(riddleId)) || RIDDLE_DEFINITION_MAP[riddleId] || {};
                const mergedSignature = values.signature !== '' ? values.signature : (baseDefinition.signature || '');
                const definition = {
                    ...baseDefinition,
                    heading: values.heading,
                    yellow: values.yellow,
                    white: values.white,
                    signature: mergedSignature,
                    answers: values.answers,
                    normalizedAnswers: new Set(normalizedAnswersArray)
                };
                refreshRiddleDefinition(definition);
            }

            hideRiddleEditor(riddleId);
            renderDevConsoleRiddles();
            updateDevConsoleRiddleFeedback(true, `Riddle ${riddleId} updated.`);
            
            // Dynamically update the riddle display if it's currently being shown
            if (currentPage === 'riddle') {
                const playerName = getActivePlayerName();
                
                // Check if editing the intro riddle and it's currently displayed
                if (String(riddleId) === String(INTRO_RIDDLE_ID) && !activeRiddleChallenge) {
                    renderIntroOnly(playerName);
                }
                // Check if editing the current challenge riddle
                else if (activeRiddleChallenge && !activeRiddleChallenge.completed && !isShowingRiddleCompletion) {
                    const currentRiddleInChallenge = activeRiddleChallenge.riddles[activeRiddleChallenge.index];
                    if (currentRiddleInChallenge && String(currentRiddleInChallenge.id) === String(riddleId)) {
                        // Update the riddle in the challenge array with the new definition
                        const updatedDefinition = RIDDLE_DEFINITION_MAP[riddleId];
                        if (updatedDefinition) {
                            activeRiddleChallenge.riddles[activeRiddleChallenge.index] = updatedDefinition;
                            renderCurrentChallengeRiddle(false); // false = no transition
                        }
                    }
                }
            }
        }

        function deleteRiddle(riddleId) {
            if (!riddleId) {
                return;
            }
            
            // Check if this riddle is currently being displayed in an active challenge
            if (activeRiddleChallenge && !activeRiddleChallenge.completed && !isShowingRiddleCompletion) {
                const isInActiveChallenge = activeRiddleChallenge.riddles.some(riddle => 
                    String(riddle.id) === String(riddleId)
                );
                if (isInActiveChallenge) {
                    updateDevConsoleRiddleFeedback(false, `Cannot delete riddle ${riddleId} - it's in the active challenge. Complete or reset the challenge first.`);
                    return;
                }
            }
            
            // Check if this is the intro riddle being displayed
            if (currentPage === 'riddle' && String(riddleId) === String(INTRO_RIDDLE_ID) && !activeRiddleChallenge) {
                updateDevConsoleRiddleFeedback(false, `Cannot delete the intro riddle while it's being displayed. Reset to login first.`);
                return;
            }

            const overrides = loadRiddleOverrides();
            const removed = loadRemovedRiddleIds();
            const customRiddles = loadCustomRiddles();
            const isCustom = String(riddleId).startsWith('custom');

            if (isCustom) {
                const filtered = customRiddles.filter(riddle => String(riddle.id) !== String(riddleId));
                saveCustomRiddles(filtered);
            } else {
                removed.add(String(riddleId));
                delete overrides[riddleId];
                saveRiddleOverrides(overrides);
                saveRemovedRiddleIds(removed);
            }

            delete RIDDLE_DEFINITION_MAP[riddleId];
            for (let i = RIDDLE_DEFINITIONS.length - 1; i >= 0; i -= 1) {
                if (String(RIDDLE_DEFINITIONS[i].id) === String(riddleId)) {
                    RIDDLE_DEFINITIONS.splice(i, 1);
                }
            }

            renderDevConsoleRiddles();
            updateDevConsoleRiddleFeedback(true, `Riddle ${riddleId} removed.`);
        }

        function exportRiddles() {
            const data = {
                custom: loadCustomRiddles(),
                overrides: loadRiddleOverrides(),
                removed: Array.from(loadRemovedRiddleIds())
            };

            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = 'riddles-export.json';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            updateDevConsoleRiddleFeedback(true, 'Riddle data exported.');
        }

        function importRiddles(file) {
            if (!file) {
                return;
            }

            const reader = new FileReader();
            reader.onload = event => {
                try {
                    const parsed = JSON.parse(event.target.result);
                    if (parsed.custom && Array.isArray(parsed.custom)) {
                        saveCustomRiddles(parsed.custom);
                    }
                    if (parsed.overrides && typeof parsed.overrides === 'object') {
                        saveRiddleOverrides(parsed.overrides);
                    }
                    if (parsed.removed && Array.isArray(parsed.removed)) {
                        saveRemovedRiddleIds(new Set(parsed.removed.map(String)));
                    }
                    restoreCustomRiddles();
                    renderDevConsoleRiddles();
                    updateDevConsoleRiddleFeedback(true, 'Riddle import completed.');
                    
                    // Dynamically update the riddle display if on riddle page
                    if (currentPage === 'riddle') {
                        const playerName = getActivePlayerName();
                        
                        // If viewing intro riddle, re-render it
                        if (!activeRiddleChallenge) {
                            const intro = RIDDLE_DEFINITION_MAP[INTRO_RIDDLE_ID];
                            if (intro) {
                                renderIntroOnly(playerName);
                            }
                        }
                        // If in an active challenge, update current riddle
                        else if (activeRiddleChallenge && !activeRiddleChallenge.completed && !isShowingRiddleCompletion) {
                            const currentIndex = activeRiddleChallenge.index;
                            const currentRiddleId = activeRiddleChallenge.riddles[currentIndex]?.id;
                            const updatedDefinition = RIDDLE_DEFINITION_MAP[currentRiddleId];
                            
                            if (updatedDefinition) {
                                // Update the riddle in the challenge array
                                activeRiddleChallenge.riddles[currentIndex] = updatedDefinition;
                                renderCurrentChallengeRiddle(false); // false = no transition
                            }
                        }
                    }
                } catch (error) {
                    updateDevConsoleRiddleFeedback(false, 'Failed to import riddles. Check file format.');
                }
            };
            reader.readAsText(file);
        }

        function loadRiddleDefinition(id) {
            return RIDDLE_DEFINITION_MAP[id] || null;
        }

        function refreshRiddleDefinition(definition) {
            if (!definition) {
                return;
            }

            const index = RIDDLE_DEFINITIONS.findIndex(riddle => riddle.id === definition.id);
            if (index >= 0) {
                RIDDLE_DEFINITIONS[index] = definition;
            } else {
                RIDDLE_DEFINITIONS.push(definition);
            }

            RIDDLE_DEFINITION_MAP[definition.id] = definition;
        }

        function refreshDevConsolePagesActiveState() {
            const { pageList } = DevConsoleState.elements;
            if (!pageList) {
                return;
            }

            pageList.querySelectorAll('.dev-console-list-item').forEach(button => {
                const pageId = button.dataset.page;
                
                // Use same highlighting logic as renderDevConsolePages
                let isActive = false;
                if (pageId === 'riddleCompletion') {
                    // Highlight riddleCompletion if we're on riddle page AND showing completion
                    isActive = (currentPage === 'riddle' && isShowingRiddleCompletion);
                } else if (pageId === 'riddle') {
                    // Highlight riddle if we're on riddle page AND NOT showing completion
                    isActive = (currentPage === 'riddle' && !isShowingRiddleCompletion);
                } else {
                    // For other pages, just check currentPage
                    isActive = (currentPage === pageId);
                }
                
                button.classList.toggle('is-active', isActive);
            });
        }

        function refreshDevConsoleIfVisible() {
            if (!DevConsoleState.isVisible || !DevConsoleState.isUnlocked) {
                return;
            }

            refreshDevConsolePagesActiveState();
            if (DevConsoleState.activePanel === 'accounts') {
                renderDevConsoleAccounts();
            } else if (DevConsoleState.activePanel === 'riddles') {
                renderDevConsoleRiddles();
            }
        }

        function getCompletionElements() {
            return {
                page: document.getElementById('riddlePage'),
                container: document.getElementById('completionContainer'),
                rewards: document.getElementById('completionRewards'),
                buttons: Array.from(document.querySelectorAll('.completion-reward-button')),
                selector: document.getElementById('completionSelector')
            };
        }

        function showCompletionView(playerName, signature) {
            const { page, container, selector, buttons } = getCompletionElements();
            if (page) {
                page.classList.add('is-completion');
            }
            if (container) {
                container.setAttribute('aria-hidden', 'false');
            }
            if (selector) {
                selector.style.opacity = '0';
                selector.style.transform = 'translateX(-9999px)';
            }
            const hasSelection = Boolean(activeRiddleChallenge?.selectedReward);
            const isSubmitted = Boolean(activeRiddleChallenge?.rewardSubmitted);
            buttons.forEach(button => {
                button.disabled = isSubmitted;
                button.tabIndex = isSubmitted ? -1 : 0;
            });
            const submitBtn = document.getElementById('completionSubmitBtn');
            if (submitBtn) {
                submitBtn.disabled = !hasSelection || isSubmitted;
                submitBtn.textContent = isSubmitted ? 'Reward Submitted' : 'Submit Reward';
            }
        }

        function hideCompletionView() {
            const { page, container, selector, buttons } = getCompletionElements();
            if (page) {
                page.classList.remove('is-completion');
            }
            if (container) {
                container.setAttribute('aria-hidden', 'true');
            }
            if (selector) {
                selector.style.opacity = '0';
                selector.style.transform = 'translateX(-9999px)';
            }
            buttons.forEach(button => {
                button.disabled = false;
                button.tabIndex = 0;
            });
            const submitBtn = document.getElementById('completionSubmitBtn');
            if (submitBtn) {
                submitBtn.disabled = true;
                submitBtn.textContent = 'Submit Reward';
            }
        }

        function updateCompletionSelectionUI(selectedReward, { skipPersist = false } = {}) {
            const elements = getCompletionElements();
            if (!elements.buttons.length) {
                return;
            }

            elements.buttons.forEach(button => {
                const rewardType = button.dataset.reward;
                const art = button.querySelector('.completion-reward-art');
                const isSelected = selectedReward === rewardType;
                button.setAttribute('aria-pressed', isSelected ? 'true' : 'false');
                button.classList.toggle('is-selected', isSelected);

                if (art && COMPLETION_REWARD_ART_MAP[rewardType]) {
                    art.src = COMPLETION_REWARD_ART_MAP[rewardType][isSelected ? 'selected' : 'unselected'];
                }
            });

            if (elements.selector) {
            const activeButton = elements.buttons.find(btn => btn.dataset.reward === selectedReward);
            if (activeButton && elements.rewards) {
                const buttonRect = activeButton.getBoundingClientRect();
                const containerRect = elements.rewards.getBoundingClientRect();
                const selectorWidth = elements.selector.offsetWidth || 74;
                const offsetX = (buttonRect.left + buttonRect.width / 2) - containerRect.left - (selectorWidth / 2);
                elements.selector.style.transform = `translateX(${offsetX}px)`;
                elements.selector.style.opacity = '1';
            } else {
                elements.selector.style.transform = 'translateX(-9999px)';
                elements.selector.style.opacity = '0';
            }
            }

            if (!skipPersist && activeRiddleChallenge) {
                activeRiddleChallenge.selectedReward = selectedReward;
                saveActiveChallenge();
            }

            const submitBtn = document.getElementById('completionSubmitBtn');
            const isSubmitted = Boolean(activeRiddleChallenge?.rewardSubmitted);
            if (submitBtn && !isSubmitted) {
                submitBtn.disabled = !selectedReward;
            }
        }

        function setupCompletionRewardEvents() {
            const { buttons } = getCompletionElements();
            if (!buttons.length) {
                return;
            }

            buttons.forEach(button => {
                button.addEventListener('click', () => {
                    if (!activeRiddleChallenge) {
                        return;
                    }
                    const reward = button.dataset.reward;
                    updateCompletionSelectionUI(reward);
                });
            });

            const submitBtn = document.getElementById('completionSubmitBtn');
            if (submitBtn) {
                submitBtn.addEventListener('click', handleCompletionSubmit);
            }

            const closeBtn = document.getElementById('completionModalClose');
            const modal = document.getElementById('completionModal');
            if (closeBtn) {
                closeBtn.addEventListener('click', hideCompletionModal);
            }
            modal?.addEventListener('click', (event) => {
                if (event.target === modal || event.target.classList.contains('completion-modal-backdrop')) {
                    hideCompletionModal();
                }
            });
        }

        function handleCompletionSubmit() {
            if (!activeRiddleChallenge || !activeRiddleChallenge.selectedReward) {
                return;
            }

            activeRiddleChallenge.rewardSubmitted = true;
            saveActiveChallenge();

            const { buttons, selector } = getCompletionElements();
            buttons.forEach(button => {
                button.disabled = true;
                button.tabIndex = -1;
            });
            if (selector) {
                selector.style.opacity = '0.85';
            }

            const submitBtn = document.getElementById('completionSubmitBtn');
            if (submitBtn) {
                submitBtn.disabled = true;
                submitBtn.textContent = 'Reward Submitted';
            }

            showCompletionModal();
        }

        function showCompletionModal() {
            const modal = document.getElementById('completionModal');
            if (!modal) {
                return;
            }
            modal.classList.add('is-visible');
            modal.setAttribute('aria-hidden', 'false');
            document.getElementById('completionModalClose')?.focus({ preventScroll: true });
        }

        function hideCompletionModal() {
            const modal = document.getElementById('completionModal');
            if (!modal) {
                return;
            }
            modal.classList.remove('is-visible');
            modal.setAttribute('aria-hidden', 'true');
            document.getElementById('completionSubmitBtn')?.focus({ preventScroll: true });
        }

    </script>
    </div>
</body>
</html>
